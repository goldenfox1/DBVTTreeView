<!DOCTYPE html>
<!-- saved from url=(0031)http://delphigears.blogspot.ru/ -->
<html class="v2" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xmlns:b="http://www.google.com/2005/gml/b" xmlns:data="http://www.google.com/2005/gml/data" xmlns:expr="http://www.google.com/2005/gml/expr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="IE=EmulateIE7" http-equiv="X-UA-Compatible">
<meta content="width=1100" name="viewport">

<meta content="blogger" name="generator">
<link href="http://delphigears.blogspot.ru/favicon.ico" rel="icon" type="image/x-icon">
<link href="http://delphigears.blogspot.com/" rel="canonical">
<link rel="alternate" type="application/atom+xml" title="Delphi Gears - Atom" href="http://delphigears.blogspot.com/feeds/posts/default">
<link rel="alternate" type="application/rss+xml" title="Delphi Gears - RSS" href="http://delphigears.blogspot.com/feeds/posts/default?alt=rss">
<link rel="service.post" type="application/atom+xml" title="Delphi Gears - Atom" href="https://www.blogger.com/feeds/7144240761607552042/posts/default">
<link rel="me" href="https://www.blogger.com/profile/17990985288407310874">
<link rel="openid.server" href="https://www.blogger.com/openid-server.g">
<link rel="openid.delegate" href="http://delphigears.blogspot.com/">
<!--[if IE]><script type="text/javascript" src="https://www.blogger.com/static/v1/jsbin/4044097237-ieretrofit.js"></script>
<![endif]-->
<meta content="http://delphigears.blogspot.com/" property="og:url">
<!--[if IE]> <script> (function() { var html5 = ("abbr,article,aside,audio,canvas,datalist,details," + "figure,footer,header,hgroup,mark,menu,meter,nav,output," + "progress,section,time,video").split(','); for (var i = 0; i < html5.length; i++) { document.createElement(html5[i]); } try { document.execCommand('BackgroundImageCache', false, true); } catch(e) {} })(); </script> <![endif]-->
<title>Delphi Gears</title>
<link type="text/css" rel="stylesheet" href="./Статья_files/499549860-css_bundle_v2.css">
<link type="text/css" rel="stylesheet" href="./Статья_files/authorization.css">
<style id="page-skin-1" type="text/css"><!--
/*
-----------------------------------------------
Blogger Template Style
Name:     Simple
Designer: Josh Peterson
URL:      www.noaesthetic.com
----------------------------------------------- */
/* Variable definitions
====================
<Variable name="keycolor" description="Main Color" type="color" default="#66bbdd"/>
<Group description="Page Text" selector="body">
<Variable name="body.font" description="Font" type="font"
default="normal normal 12px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="body.text.color" description="Text Color" type="color" default="#222222"/>
</Group>
<Group description="Backgrounds" selector=".body-fauxcolumns-outer">
<Variable name="body.background.color" description="Outer Background" type="color" default="#66bbdd"/>
<Variable name="content.background.color" description="Main Background" type="color" default="#ffffff"/>
<Variable name="header.background.color" description="Header Background" type="color" default="transparent"/>
</Group>
<Group description="Links" selector=".main-outer">
<Variable name="link.color" description="Link Color" type="color" default="#2288bb"/>
<Variable name="link.visited.color" description="Visited Color" type="color" default="#888888"/>
<Variable name="link.hover.color" description="Hover Color" type="color" default="#33aaff"/>
</Group>
<Group description="Blog Title" selector=".header h1">
<Variable name="header.font" description="Font" type="font"
default="normal normal 60px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="header.text.color" description="Title Color" type="color" default="#3399bb" />
</Group>
<Group description="Blog Description" selector=".header .description">
<Variable name="description.text.color" description="Description Color" type="color"
default="#777777" />
</Group>
<Group description="Tabs Text" selector=".tabs-inner .widget li a">
<Variable name="tabs.font" description="Font" type="font"
default="normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="tabs.text.color" description="Text Color" type="color" default="#999999"/>
<Variable name="tabs.selected.text.color" description="Selected Color" type="color" default="#000000"/>
</Group>
<Group description="Tabs Background" selector=".tabs-outer .PageList">
<Variable name="tabs.background.color" description="Background Color" type="color" default="#f5f5f5"/>
<Variable name="tabs.selected.background.color" description="Selected Color" type="color" default="#eeeeee"/>
</Group>
<Group description="Post Title" selector="h3.post-title, .comments h4">
<Variable name="post.title.font" description="Font" type="font"
default="normal normal 22px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
</Group>
<Group description="Date Header" selector=".date-header">
<Variable name="date.header.color" description="Text Color" type="color"
default="#222222"/>
<Variable name="date.header.background.color" description="Background Color" type="color"
default="transparent"/>
<Variable name="date.header.font" description="Text Font" type="font"
default="normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="date.header.padding" description="Date Header Padding" type="string" default="inherit"/>
<Variable name="date.header.letterspacing" description="Date Header Letter Spacing" type="string" default="inherit"/>
<Variable name="date.header.margin" description="Date Header Margin" type="string" default="inherit"/>
</Group>
<Group description="Post Footer" selector=".post-footer">
<Variable name="post.footer.text.color" description="Text Color" type="color" default="#666666"/>
<Variable name="post.footer.background.color" description="Background Color" type="color"
default="#f9f9f9"/>
<Variable name="post.footer.border.color" description="Shadow Color" type="color" default="#eeeeee"/>
</Group>
<Group description="Gadgets" selector="h2">
<Variable name="widget.title.font" description="Title Font" type="font"
default="normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif"/>
<Variable name="widget.title.text.color" description="Title Color" type="color" default="#000000"/>
<Variable name="widget.alternate.text.color" description="Alternate Color" type="color" default="#999999"/>
</Group>
<Group description="Images" selector=".main-inner">
<Variable name="image.background.color" description="Background Color" type="color" default="#ffffff"/>
<Variable name="image.border.color" description="Border Color" type="color" default="#eeeeee"/>
<Variable name="image.text.color" description="Caption Text Color" type="color" default="#222222"/>
</Group>
<Group description="Accents" selector=".content-inner">
<Variable name="body.rule.color" description="Separator Line Color" type="color" default="#eeeeee"/>
<Variable name="tabs.border.color" description="Tabs Border Color" type="color" default="#eeeeee"/>
</Group>
<Variable name="body.background" description="Body Background" type="background"
color="#66bbdd" default="$(color) none repeat scroll top left"/>
<Variable name="body.background.override" description="Body Background Override" type="string" default=""/>
<Variable name="body.background.gradient.cap" description="Body Gradient Cap" type="url"
default="url(https://resources.blogblog.com/blogblog/data/1kt/simple/gradients_light.png)"/>
<Variable name="body.background.gradient.tile" description="Body Gradient Tile" type="url"
default="url(https://resources.blogblog.com/blogblog/data/1kt/simple/body_gradient_tile_light.png)"/>
<Variable name="content.background.color.selector" description="Content Background Color Selector" type="string" default=".content-inner"/>
<Variable name="content.padding" description="Content Padding" type="length" default="10px" min="0" max="100px"/>
<Variable name="content.padding.horizontal" description="Content Horizontal Padding" type="length" default="10px" min="0" max="100px"/>
<Variable name="content.shadow.spread" description="Content Shadow Spread" type="length" default="40px" min="0" max="100px"/>
<Variable name="content.shadow.spread.webkit" description="Content Shadow Spread (WebKit)" type="length" default="5px" min="0" max="100px"/>
<Variable name="content.shadow.spread.ie" description="Content Shadow Spread (IE)" type="length" default="10px" min="0" max="100px"/>
<Variable name="main.border.width" description="Main Border Width" type="length" default="0" min="0" max="10px"/>
<Variable name="header.background.gradient" description="Header Gradient" type="url" default="none"/>
<Variable name="header.shadow.offset.left" description="Header Shadow Offset Left" type="length" default="-1px" min="-50px" max="50px"/>
<Variable name="header.shadow.offset.top" description="Header Shadow Offset Top" type="length" default="-1px" min="-50px" max="50px"/>
<Variable name="header.shadow.spread" description="Header Shadow Spread" type="length" default="1px" min="0" max="100px"/>
<Variable name="header.padding" description="Header Padding" type="length" default="30px" min="0" max="100px"/>
<Variable name="header.border.size" description="Header Border Size" type="length" default="1px" min="0" max="10px"/>
<Variable name="header.bottom.border.size" description="Header Bottom Border Size" type="length" default="1px" min="0" max="10px"/>
<Variable name="header.border.horizontalsize" description="Header Horizontal Border Size" type="length" default="0" min="0" max="10px"/>
<Variable name="description.text.size" description="Description Text Size" type="string" default="140%"/>
<Variable name="tabs.margin.top" description="Tabs Margin Top" type="length" default="0" min="0" max="100px"/>
<Variable name="tabs.margin.side" description="Tabs Side Margin" type="length" default="30px" min="0" max="100px"/>
<Variable name="tabs.background.gradient" description="Tabs Background Gradient" type="url"
default="url(https://resources.blogblog.com/blogblog/data/1kt/simple/gradients_light.png)"/>
<Variable name="tabs.border.width" description="Tabs Border Width" type="length" default="1px" min="0" max="10px"/>
<Variable name="tabs.bevel.border.width" description="Tabs Bevel Border Width" type="length" default="1px" min="0" max="10px"/>
<Variable name="post.margin.bottom" description="Post Bottom Margin" type="length" default="25px" min="0" max="100px"/>
<Variable name="image.border.small.size" description="Image Border Small Size" type="length" default="2px" min="0" max="10px"/>
<Variable name="image.border.large.size" description="Image Border Large Size" type="length" default="5px" min="0" max="10px"/>
<Variable name="page.width.selector" description="Page Width Selector" type="string" default=".region-inner"/>
<Variable name="page.width" description="Page Width" type="string" default="auto"/>
<Variable name="main.section.margin" description="Main Section Margin" type="length" default="15px" min="0" max="100px"/>
<Variable name="main.padding" description="Main Padding" type="length" default="15px" min="0" max="100px"/>
<Variable name="main.padding.top" description="Main Padding Top" type="length" default="30px" min="0" max="100px"/>
<Variable name="main.padding.bottom" description="Main Padding Bottom" type="length" default="30px" min="0" max="100px"/>
<Variable name="paging.background"
color="#ffffff"
description="Background of blog paging area" type="background"
default="transparent none no-repeat scroll top center"/>
<Variable name="footer.bevel" description="Bevel border length of footer" type="length" default="0" min="0" max="10px"/>
<Variable name="mobile.background.overlay" description="Mobile Background Overlay" type="string"
default="transparent none repeat scroll top left"/>
<Variable name="mobile.background.size" description="Mobile Background Size" type="string" default="auto"/>
<Variable name="mobile.button.color" description="Mobile Button Color" type="color" default="#ffffff" />
<Variable name="startSide" description="Side where text starts in blog language" type="automatic" default="left"/>
<Variable name="endSide" description="Side where text ends in blog language" type="automatic" default="right"/>
*/
/* Content
----------------------------------------------- */
body {
font: normal normal 12px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #222222;
background: #66bbdd none repeat scroll top left;
padding: 0 40px 40px 40px;
}
html body .region-inner {
min-width: 0;
max-width: 100%;
width: auto;
}
h2 {
font-size: 22px;
}
a:link {
text-decoration:none;
color: #2288bb;
}
a:visited {
text-decoration:none;
color: #888888;
}
a:hover {
text-decoration:underline;
color: #33aaff;
}
.body-fauxcolumn-outer .fauxcolumn-inner {
background: transparent url(https://resources.blogblog.com/blogblog/data/1kt/simple/body_gradient_tile_light.png) repeat scroll top left;
_background-image: none;
}
.body-fauxcolumn-outer .cap-top {
position: absolute;
z-index: 1;
height: 400px;
width: 100%;
}
.body-fauxcolumn-outer .cap-top .cap-left {
width: 100%;
background: transparent url(https://resources.blogblog.com/blogblog/data/1kt/simple/gradients_light.png) repeat-x scroll top left;
_background-image: none;
}
.content-outer {
-moz-box-shadow: 0 0 40px rgba(0, 0, 0, .15);
-webkit-box-shadow: 0 0 5px rgba(0, 0, 0, .15);
-goog-ms-box-shadow: 0 0 10px #333333;
box-shadow: 0 0 40px rgba(0, 0, 0, .15);
margin-bottom: 1px;
}
.content-inner {
padding: 10px 10px;
}
.content-inner {
background-color: #ffffff;
}
/* Header
----------------------------------------------- */
.header-outer {
background: transparent none repeat-x scroll 0 -400px;
_background-image: none;
}
.Header h1 {
font: normal normal 60px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #3399bb;
text-shadow: -1px -1px 1px rgba(0, 0, 0, .2);
}
.Header h1 a {
color: #3399bb;
}
.Header .description {
font-size: 140%;
color: #777777;
}
.header-inner .Header .titlewrapper {
padding: 22px 30px;
}
.header-inner .Header .descriptionwrapper {
padding: 0 30px;
}
/* Tabs
----------------------------------------------- */
.tabs-inner .section:first-child {
border-top: 1px solid #eeeeee;
}
.tabs-inner .section:first-child ul {
margin-top: -1px;
border-top: 1px solid #eeeeee;
border-left: 0 solid #eeeeee;
border-right: 0 solid #eeeeee;
}
.tabs-inner .widget ul {
background: #f5f5f5 url(https://resources.blogblog.com/blogblog/data/1kt/simple/gradients_light.png) repeat-x scroll 0 -800px;
_background-image: none;
border-bottom: 1px solid #eeeeee;
margin-top: 0;
margin-left: -30px;
margin-right: -30px;
}
.tabs-inner .widget li a {
display: inline-block;
padding: .6em 1em;
font: normal normal 14px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #999999;
border-left: 1px solid #ffffff;
border-right: 1px solid #eeeeee;
}
.tabs-inner .widget li:first-child a {
border-left: none;
}
.tabs-inner .widget li.selected a, .tabs-inner .widget li a:hover {
color: #000000;
background-color: #eeeeee;
text-decoration: none;
}
/* Columns
----------------------------------------------- */
.main-outer {
border-top: 0 solid #eeeeee;
}
.fauxcolumn-left-outer .fauxcolumn-inner {
border-right: 1px solid #eeeeee;
}
.fauxcolumn-right-outer .fauxcolumn-inner {
border-left: 1px solid #eeeeee;
}
/* Headings
----------------------------------------------- */
div.widget > h2,
div.widget h2.title {
margin: 0 0 1em 0;
font: normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
color: #000000;
}
/* Widgets
----------------------------------------------- */
.widget .zippy {
color: #999999;
text-shadow: 2px 2px 1px rgba(0, 0, 0, .1);
}
.widget .popular-posts ul {
list-style: none;
}
/* Posts
----------------------------------------------- */
h2.date-header {
font: normal bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
}
.date-header span {
background-color: transparent;
color: #222222;
padding: inherit;
letter-spacing: inherit;
margin: inherit;
}
.main-inner {
padding-top: 30px;
padding-bottom: 30px;
}
.main-inner .column-center-inner {
padding: 0 15px;
}
.main-inner .column-center-inner .section {
margin: 0 15px;
}
.post {
margin: 0 0 25px 0;
}
h3.post-title, .comments h4 {
font: normal normal 22px Arial, Tahoma, Helvetica, FreeSans, sans-serif;
margin: .75em 0 0;
}
.post-body {
font-size: 110%;
line-height: 1.4;
position: relative;
}
.post-body img, .post-body .tr-caption-container, .Profile img, .Image img,
.BlogList .item-thumbnail img {
padding: 2px;
background: #ffffff;
border: 1px solid #eeeeee;
-moz-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
-webkit-box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
box-shadow: 1px 1px 5px rgba(0, 0, 0, .1);
}
.post-body img, .post-body .tr-caption-container {
padding: 5px;
}
.post-body .tr-caption-container {
color: #222222;
}
.post-body .tr-caption-container img {
padding: 0;
background: transparent;
border: none;
-moz-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
-webkit-box-shadow: 0 0 0 rgba(0, 0, 0, .1);
box-shadow: 0 0 0 rgba(0, 0, 0, .1);
}
.post-header {
margin: 0 0 1.5em;
line-height: 1.6;
font-size: 90%;
}
.post-footer {
margin: 20px -2px 0;
padding: 5px 10px;
color: #666666;
background-color: #f9f9f9;
border-bottom: 1px solid #eeeeee;
line-height: 1.6;
font-size: 90%;
}
#comments .comment-author {
padding-top: 1.5em;
border-top: 1px solid #eeeeee;
background-position: 0 1.5em;
}
#comments .comment-author:first-child {
padding-top: 0;
border-top: none;
}
.avatar-image-container {
margin: .2em 0 0;
}
#comments .avatar-image-container img {
border: 1px solid #eeeeee;
}
/* Comments
----------------------------------------------- */
.comments .comments-content .icon.blog-author {
background-repeat: no-repeat;
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEgAACxIB0t1+/AAAAAd0SU1FB9sLFwMeCjjhcOMAAAD+SURBVDjLtZSvTgNBEIe/WRRnm3U8RC1neQdsm1zSBIU9VVF1FkUguQQsD9ITmD7ECZIJSE4OZo9stoVjC/zc7ky+zH9hXwVwDpTAWWLrgS3QAe8AZgaAJI5zYAmc8r0G4AHYHQKVwII8PZrZFsBFkeRCABYiMh9BRUhnSkPTNCtVXYXURi1FpBDgArj8QU1eVXUzfnjv7yP7kwu1mYrkWlU33vs1QNu2qU8pwN0UpKoqokjWwCztrMuBhEhmh8bD5UDqur75asbcX0BGUB9/HAMB+r32hznJgXy2v0sGLBcyAJ1EK3LFcbo1s91JeLwAbwGYu7TP/3ZGfnXYPgAVNngtqatUNgAAAABJRU5ErkJggg==);
}
.comments .comments-content .loadmore a {
border-top: 1px solid #999999;
border-bottom: 1px solid #999999;
}
.comments .comment-thread.inline-thread {
background-color: #f9f9f9;
}
.comments .continue {
border-top: 2px solid #999999;
}
/* Accents
---------------------------------------------- */
.section-columns td.columns-cell {
border-left: 1px solid #eeeeee;
}
.blog-pager {
background: transparent none no-repeat scroll top center;
}
.blog-pager-older-link, .home-link,
.blog-pager-newer-link {
background-color: #ffffff;
padding: 5px;
}
.footer-outer {
border-top: 0 dashed #bbbbbb;
}
/* Mobile
----------------------------------------------- */
body.mobile  {
background-size: auto;
}
.mobile .body-fauxcolumn-outer {
background: transparent none repeat scroll top left;
}
.mobile .body-fauxcolumn-outer .cap-top {
background-size: 100% auto;
}
.mobile .content-outer {
-webkit-box-shadow: 0 0 3px rgba(0, 0, 0, .15);
box-shadow: 0 0 3px rgba(0, 0, 0, .15);
}
.mobile .tabs-inner .widget ul {
margin-left: 0;
margin-right: 0;
}
.mobile .post {
margin: 0;
}
.mobile .main-inner .column-center-inner .section {
margin: 0;
}
.mobile .date-header span {
padding: 0.1em 10px;
margin: 0 -10px;
}
.mobile h3.post-title {
margin: 0;
}
.mobile .blog-pager {
background: transparent none no-repeat scroll top center;
}
.mobile .footer-outer {
border-top: none;
}
.mobile .main-inner, .mobile .footer-inner {
background-color: #ffffff;
}
.mobile-index-contents {
color: #222222;
}
.mobile-link-button {
background-color: #2288bb;
}
.mobile-link-button a:link, .mobile-link-button a:visited {
color: #ffffff;
}
.mobile .tabs-inner .section:first-child {
border-top: none;
}
.mobile .tabs-inner .PageList .widget-content {
background-color: #eeeeee;
color: #000000;
border-top: 1px solid #eeeeee;
border-bottom: 1px solid #eeeeee;
}
.mobile .tabs-inner .PageList .widget-content .pagelist-arrow {
border-left: 1px solid #eeeeee;
}

--></style>
<style id="template-skin-1" type="text/css"><!--
body {
min-width: 1500px;
}
.content-outer, .content-fauxcolumn-outer, .region-inner {
min-width: 1500px;
max-width: 1500px;
_width: 1500px;
}
.main-inner .columns {
padding-left: 0px;
padding-right: 310px;
}
.main-inner .fauxcolumn-center-outer {
left: 0px;
right: 310px;
/* IE6 does not respect left and right together */
_width: expression(this.parentNode.offsetWidth -
parseInt("0px") -
parseInt("310px") + 'px');
}
.main-inner .fauxcolumn-left-outer {
width: 0px;
}
.main-inner .fauxcolumn-right-outer {
width: 310px;
}
.main-inner .column-left-outer {
width: 0px;
right: 100%;
margin-left: -0px;
}
.main-inner .column-right-outer {
width: 310px;
margin-right: -310px;
}
#layout {
min-width: 0;
}
#layout .content-outer {
min-width: 0;
width: 800px;
}
#layout .region-inner {
min-width: 0;
width: auto;
}
--></style>
<script src="./Статья_files/cb=gapi.loaded_2" async=""></script><script src="./Статья_files/cb=gapi.loaded_1" async=""></script><script src="./Статья_files/cb=gapi.loaded_0" async=""></script><script type="text/javascript">function a(){var b=window.location.href,c=b.split("?");switch(c.length){case 1:return b+"?m=1";case 2:return 0<=c[1].search("(^|&)m=")?null:b+"&m=1";default:return null}}var d=navigator.userAgent;if(-1!=d.indexOf("Mobile")&&-1!=d.indexOf("WebKit")&&-1==d.indexOf("iPad")||-1!=d.indexOf("Opera Mini")||-1!=d.indexOf("IEMobile")){var e=a();e&&window.location.replace(e)};
</script><script type="text/javascript" src="./Статья_files/google_top_exp.js"></script><style>.gc-bubbleDefault{background-color:transparent !important;text-align:left;padding:0 !important;margin:0 !important;border:0 !important;table-layout:auto !important}.gc-reset{background-color:transparent !important;border:0 !important;padding:0 !important;margin:0 !important;text-align:left}.pls-bubbleTop{border-bottom:1px solid #ccc !important}.pls-topTail,.pls-vertShimLeft,.pls-contentLeft{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/border_3.gif) !important}.pls-topTail{background-repeat:repeat-x !important;background-position:bottom !important}.pls-vertShim{background-color:#fff !important;text-align:right}.tbl-grey .pls-vertShim{background-color:#f5f5f5 !important}.pls-vertShimLeft{background-repeat:repeat-y !important;background-position:right !important;height:4px}.pls-vertShimRight{height:4px}.pls-confirm-container .pls-vertShim{background-color:#fff3c2 !important}.pls-contentWrap{background-color:#fff !important;position:relative !important;vertical-align:top}.pls-contentLeft{background-repeat:repeat-y;background-position:right;vertical-align:top}.pls-dropRight{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleDropR_3.png) !important;background-repeat:repeat-y !important;vertical-align:top}.pls-vert,.pls-tailleft,.pls-dropTR .pls-dropBR,.pls-dropBL,.pls-vert img{vertical-align:top}.pls-dropBottom{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleDropB_3.png) !important;background-repeat:repeat-x !important;width:100%;vertical-align:top}.pls-topLeft{background:inherit !important;text-align:right;vertical-align:bottom}.pls-topRight{background:inherit !important;text-align:left;vertical-align:bottom}.pls-bottomLeft{background:inherit !important;text-align:right}.pls-bottomRight{background:inherit !important;text-align:left;vertical-align:top}.pls-tailtop,.pls-tailright,.pls-tailbottom,.pls-tailleft{display:none;position:relative}.pls-tailbottom,.pls-tailtop,.pls-tailright,.pls-tailleft,.pls-dropTR,.pls-dropBR,.pls-dropBL{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleSprite_3.png) !important;background-repeat:no-repeat}.tbl-grey .pls-tailbottom,.tbl-grey .pls-tailtop,.tbl-grey .pls-tailright,.tbl-grey .pls-tailleft,.tbl-grey .pls-dropTR,.tbl-grey .pls-dropBR,.tbl-grey .pls-dropBL{background-image:url(//ssl.gstatic.com/s2/oz/images/stars/po/bubblev1/bubbleSprite-grey.png) !important}.pls-tailbottom{background-position:-23px 0}.pls-confirm-container .pls-tailbottom{background-position:-23px -10px}.pls-tailtop{background-position:-19px -20px}.pls-tailright{background-position:0 0}.pls-tailleft{background-position:-10px 0}.pls-tailtop{vertical-align:top}.gc-bubbleDefault td{line-height:0;font-size:0}.pls-topLeft img,.pls-topRight img,.pls-tailbottom{vertical-align:bottom}.pls-bottomLeft img,.bubbleDropTR,.pls-dropBottomL img,.pls-dropBottom img,.pls-dropBottomR img,.pls-bottomLeft{vertical-align:top}.pls-dropTR{background-position:0 -22px}.pls-dropBR{background-position:0 -27px}.pls-dropBL{background-position:0 -16px}.pls-spacertop,.pls-spacerright,.pls-spacerbottom,.pls-spacerleft{position:static !important}.pls-spinner{bottom:0;position:absolute;left:0;margin:auto;right:0;top:0} </style></head>
<body class=" variant-pale">
<div class="navbar section" id="navbar"><div class="widget Navbar" data-version="1" id="Navbar1"><script type="text/javascript">
    function setAttributeOnload(object, attribute, val) {
      if(window.addEventListener) {
        window.addEventListener('load',
          function(){ object[attribute] = val; }, false);
      } else {
        window.attachEvent('onload', function(){ object[attribute] = val; });
      }
    }
  </script>
<div id="navbar-iframe-container"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="" tabindex="0" vspace="0" width="100%" id="navbar-iframe" name="navbar-iframe" src="./Статья_files/navbar.html"></iframe></div>
<script type="text/javascript" src="./Статья_files/plusone.js" gapi_processed="true"></script>
<script type="text/javascript">
      gapi.load("gapi.iframes:gapi.iframes.style.bubble", function() {
        if (gapi.iframes && gapi.iframes.getContext) {
          gapi.iframes.getContext().openChild({
              url: 'https://www.blogger.com/navbar.g?targetBlogID\x3d7144240761607552042\x26blogName\x3dDelphi+Gears\x26publishMode\x3dPUBLISH_MODE_BLOGSPOT\x26navbarType\x3dBLUE\x26layoutType\x3dLAYOUTS\x26searchRoot\x3dhttp://delphigears.blogspot.com/search\x26blogLocale\x3dru\x26v\x3d2\x26homepageUrl\x3dhttp://delphigears.blogspot.com/\x26vt\x3d2219202886855405158',
              where: document.getElementById("navbar-iframe-container"),
              id: "navbar-iframe"
          });
        }
      });
    </script><script type="text/javascript">
(function() {
var script = document.createElement('script');
script.type = 'text/javascript';
script.src = '//pagead2.googlesyndication.com/pagead/js/google_top_exp.js';
var head = document.getElementsByTagName('head')[0];
if (head) {
head.appendChild(script);
}})();
</script>
</div></div>
<div class="body-fauxcolumns">
<div class="fauxcolumn-outer body-fauxcolumn-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<div class="content">
<div class="content-fauxcolumns">
<div class="fauxcolumn-outer content-fauxcolumn-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<div class="content-outer">
<div class="content-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left content-fauxborder-left">
<div class="fauxborder-right content-fauxborder-right"></div>
<div class="content-inner">
<!-- Syntax Highlighter Additions START -->
<link href="./Статья_files/shCore.css" rel="stylesheet" type="text/css">
<link href="./Статья_files/shThemeDefault.css" rel="stylesheet" type="text/css">
<!-- <link href='http://alexgorbatchev.com/pub/sh/current/styles/shCore.css' rel='stylesheet' type='text/css'/> -->
<!-- <link href='http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css' rel='stylesheet' type='text/css'/> -->
<script src="./Статья_files/shCore.js" type="text/javascript"></script>
<script src="./Статья_files/shBrushDelphi.js" type="text/javascript"></script>
<script language="javascript" type="text/javascript">
	SyntaxHighlighter.config.bloggerMode = true;
	SyntaxHighlighter.all();
</script>
<!-- Syntax Highlighter Additions END -->
<header>
<div class="header-outer">
<div class="header-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left header-fauxborder-left">
<div class="fauxborder-right header-fauxborder-right"></div>
<div class="region-inner header-inner">
<div class="header section" id="header"><div class="widget Header" data-version="1" id="Header1">
<div id="header-inner">
<div class="titlewrapper">
<h1 class="title">
Delphi Gears
</h1>
</div>
<div class="descriptionwrapper">
<p class="description"><span>
</span></p>
</div>
</div>
</div></div>
</div>
</div>
<div class="header-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</header>
<div class="tabs-outer">
<div class="tabs-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left tabs-fauxborder-left">
<div class="fauxborder-right tabs-fauxborder-right"></div>
<div class="region-inner tabs-inner">
<div class="tabs no-items section" id="crosscol"></div>
<div class="tabs no-items section" id="crosscol-overflow"></div>
</div>
</div>
<div class="tabs-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="main-outer">
<div class="main-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left main-fauxborder-left">
<div class="fauxborder-right main-fauxborder-right"></div>
<div class="region-inner main-inner">
<div class="columns fauxcolumns">
<div class="fauxcolumn-outer fauxcolumn-center-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="fauxcolumn-outer fauxcolumn-left-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<div class="fauxcolumn-outer fauxcolumn-right-outer">
<div class="cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left">
<div class="fauxborder-right"></div>
<div class="fauxcolumn-inner">
</div>
</div>
<div class="cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<!-- corrects IE6 width calculation -->
<div class="columns-inner">
<div class="column-center-outer">
<div class="column-center-inner">
<div class="main section" id="main"><div class="widget Blog" data-version="1" id="Blog1">
<div class="blog-posts hfeed">

          <div class="date-outer">
        
<h2 class="date-header"><span>среда, 17 августа 2011 г.</span></h2>

          <div class="date-posts">
        
<div class="post-outer">
<div class="post hentry">
<a name="5600195645677483363"></a>
<h3 class="post-title entry-title">
<a href="http://delphigears.blogspot.ru/2011/08/virtual-treeview.html">Virtual Treeview</a>
</h3>
<div class="post-header">
<div class="post-header-line-1"></div>
</div>
<div class="post-body entry-content" id="post-body-5600195645677483363">
<div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on"><div dir="ltr" style="text-align: left;" trbidi="on">Компонент отображения деревьев и списков: Virtual Treeview.<br>
Приёмы использования в проектах.<br>
http://www.soft-gems.net<br>
<br>
<b>1.0. Введение</b><br>
Всё  чаще стали встречаться вопросы по этому, безусловно, отличному  компоненту, и всё больше программистов переписывают свои проекты для  использования с VT (здесь и далее Я буду применять сокращение «VT»,  вместо «Virtual Treeview»). Соответственно назрела идея написания этой  статьи. Да и не просто назрела, а стала необходимостью, так как  существующий по компоненту официальный документ не приводит толком  никакого кода, ограничиваясь лишь пустым описанием возможностей и  иерархий классов. В этой статье Я хотел бы осветить следующее:<br>
<ul><li>Назначение компонента;&nbsp;</li>
<li>Его  преимущества или недостатки перед стандартными TTreeView и TListView  (да, да, несмотря на своё название, VT является помесью и того и другого  одновременно);</li>
<li>Приёмы и примеры использования компонента в Ваших проектах;</li>
<li>А также предостеречь Вас о возможных ошибках при неправильном использовании компонента.</li>
</ul>Сразу  хочу сказать, что компонент поначалу может показаться Вам слишком  громоздким и тяжелым. Но уверяю Вас, как только Вы сделаете первые шаги и  начнете работать с этим компонентом, Вы долго потом будете удивляться,  почему сразу всё не было реализовано именно так, как это сделано в VT.<br>
<br>
<b>1.1. TVirtualTreeView - проект SoftGems (http://www.soft-gems.net).</b><br>
История компонента начинается в дремучем 1999 году, когда его автор и по существу единственный разработчик вообще,&nbsp;<b>Mike Lischke</b>,  после релиза TreeNT (прародителя VT) устроился на новое место работы.  Внедряя TreeNT в корпоративную библиотеку компании, он впервые осознал  как велико различие между требованиями к индивидуальному,  профессиональному программному обеспечению и корпоративным разработкам.  TreeNT был враппером вокруг Microsoft'ского CommCtl32.dll компонента  (TTreeView) и потому нёс в себе все самые существенные его недостатки, а  именно: низкую скорость работы (добавление 5000-6000 узлов занимало  несколько минут), сильную зависимость от версий библиотеки и отсутствие  кроссплатформенности.<br>
Было принято решение написать компонент  отображения дерева «с нуля» на чистом VCL, который был бы ориентирован  на работу с виртуальными данными. Напомню, что это принцип, при котором  дерево абсолютно ничего не знало бы о данных своих узлов, даже их текст,  например. Единственное, о чём знает VT это структура дерева,  представленная, грубо говоря, связанным списком, где каждый элемент –  запись (TVirtualNode), хранящая служебную информацию узла (настройки,  состояние, индекс и т.д.). О том, как дерево управляется с данными,  будет сказано позже.<br>
Текущая версия компонента (4.3 на момент  написания этих строк) реализует прорву возможностей. Перечислять Я их  здесь, понятное дело, не буду – этот список займёт около двух-трёх  страниц печатного текста. Скажу только, что всё, ВСЁ, что Вы могли бы  захотеть сделать с деревом, Вы сделаете с VT. Думаю, для Вас также  приятно будет узнать, что VT используется в средах Borland, начиная с  BDS 3 (Delphi 2005), что можно считать гарантом его безупречной  стабильности в работе.<br>
<br>
<b>1.2. Применение в проектах</b><br>
Всё  бы хорошо, но какая польза может быть от этого большого, как уж ни  крути, компонента, скажем, для вашей программы-базы данных телефонной  книжки или миниатюрного просмотрщика папок, где количество узлов вряд ли  когда-нибудь превысит сотню? На самом деле всякая&nbsp;.  Помимо своих скоростных преимуществ, VT позволяет контролировать  каждый, даже самый маленький механизм своей работы. Около ста (!)  событий позволят Вам изменить отрисовку дерева (например, добавить  градиентную заливку), увеличить высоту узлов, цвет и стиль текста,  добавить всплывающую подсказку для обрезающегося длинного текста или  нарисовать подсказку самому, с помощью Ваших компонентов и методов.  Также можно самому отрисовывать колонки, заголовок каждой колонки,  отслеживать малейшие изменения дерева, определять порядок сортировки,  добавлять собственные редакторы в дерево (кроме обычного текстового поля  aka TEdit) и т.д. Словом, Я Вас уверяю, даже самая неприхотливая  программка, работающая со списками, тут же преобразится от использования  VT, прибавив в&nbsp;<b>профессиональности</b>,&nbsp;<b>интерактивности</b>&nbsp;и&nbsp;<b>технологичности</b>.<br>
<br>
<b>1.3. Иерархия классов.</b><br>
Прежде чем мы начнём, взгляните на эту схему, чтобы ознакомиться с «внутренностями» VT.<br>
Как  видите, «Virtual Treeview» это всего лишь общее название для двух  классов: TVirtualDrawTree и TVirtualStringTree, которые, в свою очередь,  являются потомками базового для всех деревьев класса –  TBaseVirtualTree.<br>
<br>
<b>2.0. Инициализация данных.</b><br>
Достаточно  истории и дифирамб, давайте приступим ближе к сабжу и напишем своё  первое приложение с VT. Скачивайте пакет для своей версии Delphi с&nbsp;<a href="http://www.soft-gems.net/VirtualTreeview/" target="_blank">http://www.soft-gems.net/VirtualTreeview/</a>&nbsp;и приготовьтесь к нашим увлекательным экспериментам<br>
<br>
<b>2.1. Базовые операции. Создание колонок. Управление контентом дерева. Инициализация данных для дерева.</b><br>
В  этой главе нашей с Вами задачей будет разобраться в том, как VT  управляет своими виртуальными данными, а также научиться грамотно  заполнять дерево и работать с его структурой. Здесь же будут рассмотрены  обработчики самых базовых событий компонента, без которых его работа  невозможна.<br>
<br>
Итак, Вы кинули компонент на форму. Перво-наперво,  неплохо было бы заполнить дерево какими-нибудь узлами, подумаете Вы. Но  не тут-то было. В этом заключается первое неудобство компонента – все  данные загружаются в дерево исключительно и только в рантайме. Тем не  менее, предусмотрено свойство&nbsp;<b>RootNodeCount</b>, настраиваемое из Object Inspector, которое позволяет добавить в дерево n-ое количество корневых элементов.<br>
<br>
<i><b>Запомните</b>: самым корневым элементом, родителем всех веток является&nbsp;<b>RootNode</b>. Это следует учитывать при рекурсивных проходах дерева. Соответственно у RootNode в поле Parent будет значиться уже&nbsp;<b>nil</b>, и в самом дереве она видна естественно не будет.<br>
<br>
При  изменении этого свойства дерево очищается и RootNode заполняется  дочерними элементами. В любом случае, забивать данными эти узлы нам всё  равно придётся в рантайме .</i><br>
<br>
Как  уже было сказано выше, физически «заполнить» VT данными невозможно. Для  работы с ними компонент использует мощный событийный механизм. Т.е. все  данные, которые Вы хотите отобразить в дереве, Вы будете отображать с  помощью событий отрисовки, получения текста и т.д. Рассмотрим пример.<br>
<br>
У нас есть некая простая база данных телефонной книжки, представленная двумя массивами: </div><br>
<pre class="brush: delphi;">Names: array[0..4] of WideString = (
  'Вася',
  'Петя',
  'Маша',
  'Костя',
  'Дима'
);
Phones: array[0..4] of WideString = (
  '433-56-49',
  '545-67-79',
  '777-50-50',
  '911-03-05',
  '02'
);
</pre></div>Как  Вы уже, наверное, заметили, нам потребуется 2 колонки для отображения  данных в нашей VT-таблице. Добавление колонок осуществляется через  класс&nbsp;<b>TVTHeader</b>&nbsp;и его поле&nbsp;<b>Columns</b>, обитающий в поле «<b>Header</b>»  у VT. Самое время сделать паузу и рассмотреть поближе наиболее  интересные настройки и свойства этого класса, назначение которого –  управлять колонками. Я буду уделять внимание только самым существенным  настройкам, думаю, Вы и сами знаете, зачем компоненту могут понадобиться  свойства наподобие&nbsp;<b>Color</b>,&nbsp;<b>ImageIndex</b>&nbsp;или&nbsp;<b>Text</b>.<br>
<ul><li><b>AutoSizeIndex</b>&nbsp;–  позволяет Вам указать какая из колонок будет иметь приоритет для  авто-подбора ширины (грубо говоря, какая колонка будет растягиваться при  изменении ширины дерева). Работает только вместе с включённой опцией  hoAutoResize.</li>
<li><b>Columns</b>&nbsp;– непосредственно редактор  колонок. Каждая колонка представляет собой экземпляр класса  TVirtualTreeColumn в коллекции. Обратим на него внимание:<ul><li><b>Layout</b>&nbsp;– определяет положение глифа (картинки) на заголовке колонки.</li>
<li><b>Margin</b>&nbsp;– задаёт отступ для текста заголовка.</li>
<li><b>MaxWidth</b>,&nbsp;<b>MinWidth</b>&nbsp;– максимально и минимально допустимая ширина колонки соответсвенно.</li>
<li><b>Options</b>&nbsp;–  индивидуальные настройки колонки, они имеют больший приоритет, чем  настройки TVTHeader, т.е. могут активировать или выключать какие-то  свойства для данной конкретной колонки, независимо от настроек всего  заголовка.<ul><li><b>coAllowClick</b>&nbsp;– аналог свойства HotTrack  для TListView и его колонок. При наведении курсора на заголовок колонки,  он будет изменять свой вид.</li>
<li><b>coDraggable</b>&nbsp;– определяет можно ли таскать колонку мышью по заголовку, меняя её положение.</li>
<li><b>coEnabled</b>,&nbsp;<b>coParentBiDiMode</b>,&nbsp;<b>coParentColor</b>,&nbsp;<b>coResizeable</b>&nbsp;–  определяют состояние, направление текста (для арабских языков, напр.),  цвет колонки, а также можно ли изменять ширину колонки.</li>
<li><b>coShowDropMark</b>&nbsp;–  определяет будет ли на заголовке колонки отрисовываться небольшой  значок, показывающий направление вставки перетаскиваемой колонки.</li>
<li><b>coAutoSpring</b>&nbsp;– очень интересное свойство. Оно определяет будет ли колонка поддерживать свойство&nbsp;<b>hoAutoSpring</b>&nbsp;у TVTHeader. Назначение этих свойств будет рассмотрено чуть ниже.</li>
<li><b>coFixed</b>&nbsp;–  если это свойство включено, то данная колонка будет полностью  заблокирована (прокрутка, доступ к узлам и т.д.) и не будет отвечать на  запросы пользователя. Очень полезно при проектировании многопотоковых  приложений, когда Вы хотите на определённый момент времени запретить  пользователю вмешиваться в содержимое этой колонки.</li>
</ul></li>
<li><b>Position</b>&nbsp;– положение колонки в заголовке.</li>
<li><b>Style</b>&nbsp;– позволяет Вам указать будет ли колонка отрисовываться по умолчанию (<b>vsText</b>) или Вы хотите переопределить её процедуру отрисовки и всё делать сами (<b>vsOwnerDraw</b>).</li>
</ul></li>
<li><b>MainColumn</b>&nbsp;–  определяет индекс основной колонки. Именно элементы этой колонки будут  выделяться синим цветом и получать фокус при выделении, и именно  напротив элементов этой колонки будут располагаться отметки и другие  дополнительные элементы управления дерева.</li>
<li><b>Options</b> – настройки заголовка. Вот тут начинается самое интересное. <b>hoAutoResize</b>&nbsp;–  если включено, то колонка с индексом из свойства AutoResizeIndex будет  занимать всё доступное пространство дерева при изменении его ширины.  Ширина такой колонки будет равна: ширина дерева – ширина всех других  колонок. Во всём дереве, понятное дело, может быть только одна такая  колонка.<ul><li><b>hoColumnResize</b>&nbsp;– Глобальное свойство, определяющее можно ли менять ширину колонок.</li>
<li><b>hoDblClickResize</b>&nbsp;–  при двойном клике на данной колонке она примет ширину самого длинного  её элемента. Рекомендуется держать в True. Опция подавляется свойством  hoAutoResize.&nbsp;</li>
<li><b>hoDrag</b>&nbsp;– определяет можно ли перетаскивать колонки.</li>
<li><b>hoRestrictDrag</b>&nbsp;– Не даёт курсору тянуть заголовок перетаскиваемой колонки к низу или вверх.</li>
<li><b>hoShowSortGlyphs</b>&nbsp;– определяет будет ли на заголовке колонки отрисовываться небольшой значок, показывающий текущее направление сортировки.</li>
<li><b>hoAutoSpring</b>&nbsp;–  вот то свойство, о котором нужно сказать отдельно. Оно позволяет  колонкам с включённым свойством coAutoSpring пропорционально изменять  свою ширину при изменении ширины дерева. Учтите, однако, что это  свойство подавляется свойством hoAutoResize.</li>
</ul></li>
<li><b>SortColumn</b>&nbsp;– индекс колонки, относительно содержания которой сортируется дерево.</li>
<li><b>SortDirection</b>&nbsp;– направление сортировки колонки с индексом SortColumn.</li>
<li><b>Style</b>&nbsp;– позволяет изменить внешний вид заголовка. Активно только при выключенных темах оформления Windows XP.</li>
</ul>Добавьте  две колонки и выставьте настройки по своему вкусу. Я установил свойство  AutoSpring у всех элементов в True, сделал заголовок видимым и добавил  ему немного высоты. Теперь нам во всеоружии можно вернуться к примеру с  телефонной книжкой, чтобы грамотно наполнить дерево контентом.<br>
<br>
Для добавления веток в дерево у VT существует два базовых метода. Это&nbsp;<b>AddChild</b>: </div><pre class="brush: pascal">function TBaseVirtualTree.AddChild(Parent: PVirtualNode; UserData: Pointer = nil): PVirtualNode;
</pre><br>
И&nbsp;<b>InsertNode</b>:<br>
<pre class="brush: pascal">function TBaseVirtualTree.InsertNode(Node: PVirtualNode; Mode: TVTNodeAttachMode; UserData: Pointer = nil): PVirtualNode;
</pre><br>
Оба  они возвращают указатель на добавленный узел. Последний отличается от  первого лишь тем, что позволяет указать позицию добавляемого узла в  свойстве&nbsp;<b>Mode</b>:<br>
<ul><li><b>amNoWhere</b>&nbsp;– узел не добавляется вообще.</li>
<li><b>amInsertBefore</b>&nbsp;– узел добавляется на позицию выше по отношению к Node.</li>
<li><b>amInsertAfter</b>&nbsp;- узел добавляется на позицию ниже по отношению к Node.</li>
<li><b>amAddChildFirst</b>&nbsp;- узел добавляется первым дочерним элементом в Node.</li>
<li><b>amAddChildLast</b>&nbsp;- узел добавляется последним дочерним элементом в Node.</li>
</ul>В нашем первом примере мы коснёмся лишь первого метода. Заполним, наконец, наше дерево: </div><pre class="brush: pascal">	
procedure TfrmMain.BtnLoadClick(Sender: TObject);
var
  i: Integer;
begin
  for i := 0 to Length(Names) - 1 do
    VT.AddChild(nil);
end;
</pre><br>
<br>
Здесь  мы просто добавили количество веток, равное количеству имён в  телефонной книжке. Но большой пользы от пустых узлов не добьёшься.  Синхронизируем наше дерево с данными. В частности, нам необходимо  отобразить текст из телефонной книжки. «Заполнение» дерева текстом  осуществляется через событие&nbsp;<b>OnGetText</b>: </div><pre class="brush: pascal">	
procedure TfrmMain.VTGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; TextType: TVSTTextType; var CellText: WideString);
begin
  case Column of
    // Текст для колонки имени
    0: CellText := Names[Node.Index];
    // Текст для колонки телефонного номера
    1: CellText := Phones[Node.Index];
  end;
end;
</pre><br>
Первый  параметр события содержит ссылку на экземпляр дерева, вызвавшего это  событие, второй – узел, для которого получаем текст, третий – индекс  колонки, для которой берётся текст, четвёртый – тип текста, будет  рассмотрен позже, и, наконец, пятый – строка, которую мы и должны  наполнить данными. В нашем примере мы просто берём текст из двух  массивов для соответствующих колонок.<br>
<br>
Теперь, когда мы реализовали обработку этого события, мы также можем получать текст посредством метода&nbsp;<b>Text</b>,  который в свою очередь вызывает событие OnGetText для получения данных.  Сделано это для Вашего удобства, чтобы не писать сотню раз код  извлечения данных из узла. </div><br>
<pre class="brush: pascal">	
property Text[Node: PVirtualNode; Column: TColumnIndex]: WideString;
</pre></div><br>
Вы  наверняка заинтересовались, а что такое CellText? Ведь дереву не нужны  никакие данные, следственно и передавать ничего не надо. Правильно, этот  параметр нужен дереву только при перерисовке дерева или при вызове  вышеупомянутого&nbsp;<b>Text</b>. Он нигде не хранится и заполняется заново при каждом событии отрисовки.<br>
<br>
<i>Проект Figure 1.0, демонстрирующий инициализацию дерева, находится в папке Fig 1.0.</i><br>
<br>
<br>
<b>2.2. Углублённая работа с данными.</b><br>
Мы  рассмотрели довольно простой пример. Но что делать, если Вы оперируете с  динамическими данными? Хранить их в динамическом массиве – затея на  грани невозможности по многим причинам. А Вам при этом требуется удалять  и добавлять ветки, изменять их содержимое и т.д.?<br>
К счастью, в  компоненте предусмотрена возможность хранения некоего указателя на  данные для каждого узла, в области памяти которого мы сможем разместить  любые нужные нам данные для каждой ветки.<br>
<br>
Рассмотрим следующий пример.<br>
Создадим универсальную телефонную книжку, которую динамически можно было бы изменять.<br>
Для  начала, решим, как на этот раз мы будем хранить данные каждой ветки.  Вариант с массивами исключён, так что же тогда? Для этого воспользуемся  записями (record), которые и будут храниться в указателе на данные для  каждого узла:</div><br>
<pre class="brush: pascal">	
type
  PPhoneNode = ^TPhoneNode;
  TPhoneNode = record
    Name, // Имя контакта
    Phone: WideString; // Телефон
  end;
</pre><br>
<br>
Но  прежде чем мы напишем код для добавления новых веток, Я хотел бы  обратить Ваше внимание на важнейшую деталь. Поскольку VT возвращает  указатель на данные, он должен как-то определять положение этих данных в  памяти, чтобы мы вдруг не получили&nbsp;<b>nil</b>&nbsp;или вообще другие данные, к дереву никак не относящиеся. Для этого в дереве предусмотрено свойство&nbsp;<b>NodeDataSize</b>,  обозначающее размер данных для каждого узла. С помощью этого свойства  дерево способно находить именно данные определённого узла посредством  метода&nbsp;<b>GetNodeData</b>: &nbsp;</div><br>
<pre class="brush: pascal">	
function TBaseVirtualTree.GetNodeData(Node: PVirtualNode): Pointer;
</pre><br>
Разработчик  обязан заполнить это свойство, если он собирается использовать такой  подход работы с данными, иначе компонент сообщит об ошибке  инициализации.<br>
Делается это предельно просто, с помощью стандартной Дельфийской функции&nbsp;<b>SizeOf</b>,  возвращающей размер блока памяти для определённого типа данных. Делать  это лучше сразу после создания формы в обработчике&nbsp;<b>OnCreate</b>: </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.FormCreate(Sender: TObject);
begin
  VT.NodeDataSize := SizeOf(TPhoneNode);
end;
</pre><br>
В нашем случае размер данных будет равен 4 байтам (по два на каждый WideString).<br>
<br>
Теперь можно смело заполнять наше дерево узлами: </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.BtnAddClick(Sender: TObject);
var
  NewNode: PVirtualNode;
  NewPhone: PPhoneNode;
begin
  NewNode := VT.AddChild(VT.FocusedNode);
  NewPhone := VT.GetNodeData(NewNode);
  if Assigned(NewPhone) then
    with NewPhone^ do
    begin
      Name := EdName.Text;
      Phone := EdPhone.Text;
    end;
end;
</pre></div><br>
Всё просто: мы добавлям ветку, получаем указатель на область её данных в памяти и заполняем эти самые данные.<br>
<br>
Позаботимся и об удалении существующих узлов. Так можно удалить узел, имеющий на данный момент фокус:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.mEntryClick(Sender: TObject);
begin
  VT.DeleteNode(VT.FocusedNode);
end;
</pre><br>
Есть также способ удалить лишь дочерние элементы узла, оставив его самого:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.mChildrenClick(Sender: TObject);
begin
  VT.DeleteChildren(VT.FocusedNode);
end;</pre><pre class="brush: pascal">&nbsp;</pre><pre class="brush: pascal">Рассмотрим теперь и вставку новых элементов с помощью метода&nbsp;<b>InsertNode</b>:
&nbsp;</pre></div><br>
<pre class="brush: pascal">	
//---------------------------------------------------------------------------
// Вставляем новый элемент перед активным узлом
//---------------------------------------------------------------------------
procedure TfrmMain.BtnInsertBeforeClick(Sender: TObject);
var
  NewNode: PVirtualNode;
  NewPhone: PPhoneNode;
begin
  NewNode := VT.InsertNode(VT.FocusedNode, amInsertBefore);
  NewPhone := VT.GetNodeData(NewNode);
  if Assigned(NewPhone) then
    with NewPhone^ do
    begin
      Name := EdName.Text;
      Phone := EdPhone.Text;
    end;
end;
//---------------------------------------------------------------------------
// Вставляем новый элемент после активного узла
//---------------------------------------------------------------------------
procedure TfrmMain.BtnInsertAfterClick(Sender: TObject);
var
  NewNode: PVirtualNode;
  NewPhone: PPhoneNode;
begin
  NewNode := VT.InsertNode(VT.FocusedNode, amInsertAfter);
  NewPhone := VT.GetNodeData(NewNode);
  if Assigned(NewPhone) then
    with NewPhone^ do
    begin
      Name := EdName.Text;
      Phone := EdPhone.Text;
    end;
end;
//---------------------------------------------------------------------------
// Вставляем новый элемент первым дочерним элементом активного узла
//---------------------------------------------------------------------------
procedure TfrmMain.BtnChildFirstClick(Sender: TObject);
var
  NewNode: PVirtualNode;
  NewPhone: PPhoneNode;
begin
  NewNode := VT.InsertNode(VT.FocusedNode, amAddChildFirst);
  NewPhone := VT.GetNodeData(NewNode);
  if Assigned(NewPhone) then
    with NewPhone^ do
    begin
      Name := EdName.Text;
      Phone := EdPhone.Text;
    end;
end;
//---------------------------------------------------------------------------
// Вставляем новый элемент последним дочерним элементом активного узла
//---------------------------------------------------------------------------
procedure TfrmMain.BtnChildLastClick(Sender: TObject);
var
  NewNode: PVirtualNode;
  NewPhone: PPhoneNode;
begin
  NewNode := VT.InsertNode(VT.FocusedNode, amAddChildLast);
  NewPhone := VT.GetNodeData(NewNode);
  if Assigned(NewPhone) then
    with NewPhone^ do
    begin
      Name := EdName.Text;
      Phone := EdPhone.Text;
    end;
end;
</pre><br>
Я  специально не стал разделять процедуры на блоки для большей  наглядности, но за Вами остаётся отдать дань полиморфизму, выделив  повторяющиеся блоки кода в отдельные методы.&nbsp;<img alt="smile" src="./Статья_files/smile_002.gif"><br>
<br>
<i>Проект Figure 1.1, демонстрирующий работу с данными в VT, заполнение дерева и редактирование лежит в папке Fig 1.1.</i><br>
<br>
<br>
<b>2.3. Обзор основных событий компонента.</b><br>
Дерево  из простых надписей не очень-то радует глаз пользователя. Давайте  добавим интерактивности в наши программы. В частности реализуем картинки  для узлов, статический текст, редактирование узлов встроенным  редактором VT, сортировку, поиск по инкременту и перебор всех элементов  дерева.<br>
<br>
Продолжая нашу тему телефонной книжки, для всего этого нам потребуется запись примерно такого содержания: </div><pre class="brush: pascal">	
type
  PPhoneNode = ^TPhoneNode;
  TPhoneNode = record
    Name, // Первая колонка
    Mobile, // Вторая колонка
    HomePhone: WideString; // Это будет статический текст второй колонки
    Enabled, // Для отображения состояния выключенности
    Editable: Boolean; // Можно ли редактировать узел
    ImageIndex: Integer; // Индекс картинки в TImageList
    Fg, Bg: TColor; // Цвет текста и фона соответсвенно
  end;
</pre></div><br>
<b>2.3.1. Отображение картинок рядом с узлами.</b><br>
Начнём  с картинок. Представим, что мы хотим позволить пользователю выбрать пол  контакта и при этом менять картинку на более тёмную, как это делает IE  при наведении на неё курсором. Нам понадобится три TImageList, чтобы на  их примере показать как в VT можно сделать отображение 3 состояний  картинки (нормальная, активная, выключенная). Если Вам лень или просто  негде взять таковые, то можете забрать их из моего примера Fig 1.2,  скачав аттач в конце статьи.<br>
<br>
По идее, картинки к VT подключаются через всем известное свойство&nbsp;<b>Images</b>.  Однако Я в процессе работы с компонентом часто замечал странные глюки  картинок, подключенных таким методом. В компоненте помимо этого есть  также свойства StateImages и CheckImages. Ни в хелпе, ни в исходниках не  даётся никакой существенной информации по всем этим трём параметрам,  поэтому Я не могу точно сказать в каких случаях какое свойство  использовать. Просто запомните, если Вы заметите какие-либо странности в  отрисовке картинок, просто поменяйте используемое свойство. В данном  примере Я использовал свойство StateImages.<br>
<br>
Получить картинку в VT можно с помощью двух почти одинаковых событий:<br>
<ul><li><b>OnGetImageIndex</b>;</li>
<li><b>OnGetImageIndexEx</b>;</li>
</ul>Если  Вы посмотрите на их входные параметры, то заметите, что отличаются они  лишь на один параметр: второе событие позволяет указывать экземпляр  TImageList, из которого будет использоваться картинка. В нашем случае  это идеальный вариант:</div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTGetImageIndexEx(Sender: TBaseVirtualTree;
  Node: PVirtualNode; Kind: TVTImageKind; Column: TColumnIndex;
  var Ghosted: Boolean; var ImageIndex: Integer;
  var ImageList: TCustomImageList);
var
  PhoneNode: PPhoneNode;
begin
  if Column &gt; 0 then
    Exit; // Картинка будет отображаться только в первой колонке
  ImageIndex := -1;
  PhoneNode := VT.GetNodeData(Node);
  if Assigned(PhoneNode) then
  begin
    ImageList := Self.ImageList; // Обычные картинки
    // HotNode – узел, над которым находится курсор,
    // т.е. активный.
    if Node = Sender.HotNode then
      ImageList := ImageListHot; // Активные картинки
    if not PhoneNode^.Enabled then
      ImageList := ImageListDisabled; // Выключенные картинки
    ImageIndex := PhoneNode^.ImageIndex;
  end;
end;
</pre><br>
Но не забывайте также и про обычное событие. Чаще всего его реализации вполне достаточно.<br>
Чтобы  пример работал корректно нужно также включить опцию  TreeOptions.PaintOptions.toHotTrack, чтобы VT имел доступ к HotNode  узлу. Т.е. к узлу, над которым в данный момент «завис» курсор.<br>
<br>
<b>2.3.2. Статический текст.</b><br>
Рассмотрим  теперь статический текст. Данная возможность предусмотрена в VT для  отображения статического, то есть нередактируемого обычными средствами  текста. Это позволит Вам запретить редактирование такого текста  стандартным редактором VT. Тем не менее, он будет отображаться рядом с  обычным текстом. Посмотрим на нашу телефонную книжку. Представьте, что  необходимо рядом с номером мобильного указать домашний телефон. При этом  мобильники некоторые люди меняют довольно часто, а вот домашний телефон  иногда остаётся на всю жизнь. Идеальное решение для такой ситуации –  использование статического текста. Перепишем событие получения текста:</div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; TextType: TVSTTextType; var CellText: WideString);
var
  PhoneNode: PPhoneNode;
begin
  PhoneNode := VT.GetNodeData(Node);
  if Assigned(PhoneNode) then
    case Column of
      0: // Имя
        if TextType = ttNormal then
          CellText := PhoneNode^.Name;
      1: // Телефон
      case TextType of
        ttNormal: CellText := PhoneNode^.Mobile; // Мобильный
        ttStatic: CellText := '(' + PhoneNode^.HomePhone + ')'; // Домашний
      end;
    end;
end;
</pre><br>
Не забудьте также разрешить отображение статического текста, включив опцию дерева&nbsp;<b>toShowStaticText</b>&nbsp;из TreeOptions.StringOptions, т.к. по умолчанию она отключена.<br>
Также  это свойство идеально подойдёт для отображения всяких префиксов или  постфиксов, например, для обозначения физических величин рядом с их  числовым значением.<br>
<br>
<b>2.3.3. Сортировка.</b><br>
Теперь  предположим, что нам необходимо сортировать контакты по алфавиту. Для  таких задач в VT имеется событие для сравнения двух узлов и обработчики  нажатий для заголовка и колонок. Попробуем всё это реализовать на  примере.<br>
<br>
Для начала обработаем событие сравнения двух узлов: </div><pre class="brush: pascal">	
procedure TfrmMain.VTCompareNodes(Sender: TBaseVirtualTree; Node1,
  Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
begin
  Result := WideCompareStr(VT.Text[Node1, Column], VT.Text[Node2, Column]);
end;
</pre><br>
В  нашем случае обработчик очень похож на WinAPI callback функции  сортировки. VT требует передачи точно такого же результата сравнения  двух элементов:<br>
<ul><li>0 – Элементы равны, оба остаются на месте.</li>
<li>0&nbsp;&lt;&nbsp;– Первый элемент больше второго.</li>
<li>0&nbsp;&gt;&nbsp;- Второй элемент больше первого.</li>
</ul>В  нашем случае всё за нас делает ОС (выбирает наибольшую по алфавиту  строку). Таким образом, если Вам нужно будет отсортировать узлы по  величине чисел, то обработчик примет примерно такой вид: </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTCompareNodes(Sender: TBaseVirtualTree; Node1,
  Node2: PVirtualNode; Column: TColumnIndex; var Result: Integer);
var
  Data1, Data2: PDataNode;
begin
  Data1 := Sender.GetNodeData(Node1);
  Data2 := Sender.GetNodeData(Node2);
  if Data1^.Value &gt; Data2^.Value then
    Result := 1
  else if Data1^.Value &lt; Data2^.Value then
    Result := -1
  else if Data1^.Value = Data1^.Value then
    Result := 0;
end;</pre></div><br>
Помните  также, что Вы не должны заботиться о порядке сортировки. Т.е. VT сам  отредактирует результат сравнения в соответствии с порядком сортировки, и  Вам не придётся писать тот же самый код дважды, меняя условия проверки  на противоположные.<br>
<br>
Теперь  нам необходимо отсортировать дерево по клику на определённую колонку  заголовка и изменить порядок сортировки на противоположный. Грубо  говоря, просто посмотрите как это делает Проводник . Делается это следующим обработчиком: &nbsp;</div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTHeaderClick(Sender: TVTHeader; Column: TColumnIndex;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if Button = mbLeft then
  begin
    // Меняем индекс сортирующей колонки на индекс колонки,
    // которая была нажата.
    VT.Header.SortColumn := Column;
    // Сортируем всё дерево относительно этой колонки
    // и изменяем порядок сортировки на противополжный
    if VT.Header.SortDirection = sdAscending then
    begin
      VT.Header.SortDirection := sdDescending;
      VT.SortTree(Column, VT.Header.SortDirection);
    end
    else begin
      VT.Header.SortDirection := sdAscending;
      VT.SortTree(Column, VT.Header.SortDirection);
    end;
  end;
end;
</pre><br>
<b>2.3.4. Работа со встроенным редактором текста.</b><br>
Идём  дальше. У TTreeView и TListView есть такая полезная возможность, как  небольшой встроенный редактор текста для узлов. Естественно VT был бы не  VT, если бы не поддерживал и эту возможность.&nbsp;<img alt="smile" src="./Статья_files/smile_002.gif"><br>
<br>
Редактор включается в настройках по адресу: TreeOptions.MiscOptions.toEditable.<br>
После этого он станет доступен также, как и в TTreeView и TListView (клик по узлу и пауза до появления).<br>
<br>
С редактором связаны такие события:<br>
<ul><li><b>OnEditing</b>&nbsp;– Происходит непосредственно&nbsp;<b>перед</b>&nbsp;появлением редактора. С помощью этого события можно запетить его появление по тем или иным причинам.</li>
<li><b>OnEdited</b>&nbsp;– Происходит сразу же после исчезновения редактора.</li>
<li><b>OnNewText</b>&nbsp;–  Происходит, если после исчезновения редактора его (редактора) текст был  изменён. С его (события) помощью можно обновить Ваши данные.</li>
<li><b>OnEditCanceled</b>&nbsp;– Происходит, если редактор был закрыт нажатием «Esc».</li>
</ul>В нашем примере мы рассмотрим два наиболее часто применяемых. Рассмотрим синхронизацию данных с новым текстом: </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTNewText(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; NewText: WideString);
var
  PhoneNode: PPhoneNode;
begin
  if Length(NewText) = 0 then
    Exit;
  PhoneNode := VT.GetNodeData(Node);
  if Assigned(PhoneNode) then
  begin
    case Column of
      0: PhoneNode^.Name := NewText;
      1: PhoneNode^.Mobile := NewText;
    end;
  end;
end;
</pre><br>
Теперь мы должны разрешить или запретить редактирование в соответствии со значением поля&nbsp;<b>Editable</b>&nbsp;нашей записи. Обработчик&nbsp;<b>onEditing</b>: </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTEditing(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; var Allowed: Boolean);
var
  PhoneNode: PPhoneNode;
begin
  Allowed := False;
  PhoneNode := VT.GetNodeData(Node);
  if Assigned(PhoneNode) then
    Allowed := PhoneNode^.Editable;
end;
</pre><br>
Не забудьте обратить внимание на параметр&nbsp;<b>EditDelay</b>. Он позволяет установить задержку перед началом редактирования узла. Значение по умолчанию – одна секунда.<br>
<br>
<b>2.3.5. Поиск по инкременту.</b><br>
Вы  уже наверняка знакомы с этой возможностью по Visual Studio и BDS.  Выглядит это примерно следующим образом: Вы постепенно вводите какой-то  текст и VT по мере ввода находит узел, текст которого наиболее совпадает  с вводимым. В конце-концов, когда Вы закончите ввод, выделенным  останется искомый узел или узел, более-менее похожий на него. Такой  подход очень полезен, когда Вы не знаете точного названия ветки, а  только её часть. В VT вся эта прелесть работает с помощью события&nbsp;<b>OnIncrementalSearch</b>:</div><pre class="brush: pascal">	
procedure TfrmMain.VTIncrementalSearch(Sender: TBaseVirtualTree;
  Node: PVirtualNode; const SearchText: WideString; var Result: Integer);
var
  PhoneNode: PPhoneNode;
  Len: Integer;
begin
  Result := 0;
  PhoneNode := VT.GetNodeData(Node);
  if Assigned(PhoneNode) then
  begin
    // Используя StrLIComp, мы можем указать длину сравнения.
    // Таким образом, мы сможем найти узлы, совпадающие частично.
    Result := StrLIComp(PAnsiChar(AnsiString(SearchText)),
      PAnsiChar(AnsiString(PhoneNode^.Name)),
       Min(Length(SearchText), Length(PhoneNode^.Name)));
  end;
end;
</pre><br>
Для  работы такого поиска надо также известить VT о том, что мы написали  соответствующий обработчик и поиск возможен. Для этого надо присвоить  параметру&nbsp;<b>IncrementalSearch</b>&nbsp;любое значение, кроме&nbsp;<b>isNone</b>:<br>
<ul><li><b>isAll</b>&nbsp;– поиск во всех узлах.</li>
<li><b>isInitializedOnly</b>&nbsp;– поиск только в инициализированных узлах. О событии инициализации будет сказано в последующих главах.</li>
<li><b>isVisibleOnly</b>&nbsp;– поиск только в видимых узлах. О таких узлах тоже будет сказано чуть позже.</li>
</ul>Параметр&nbsp;<b>IncrementalSearchDirection</b>, судя из названия, отвечает за направление поиска (вверх-вниз).<br>
<br>
Очень важен параметр&nbsp;<b>IncrementalSearchStart</b>. Он управляет диапазоном поиска. Принимает следующие значения:<br>
<ul><li><b>ssAlwaysStartOver</b>&nbsp;– при каждом новом нажатии с клавиатуры поиск начинается заново с самого первого элемента дерева. Медленно, но надёжно.</li>
<li><b>ssFocusedNode</b>&nbsp;– поиск начинается с выделенного элемента. Компромиссный вариант между двумя остальными.</li>
<li><b>ssLastHit</b>&nbsp;– самый быстрый, но не такой надёжный в плане точности параметр. Поиск начинается всегда с последнего совпадения.</li>
</ul>Параметр&nbsp;<b>IncrementalSearchTimeout</b>&nbsp;- позволяет задать паузу между двумя нажатиями клавиш. По истечении этой паузы поиск завершается.<br>
<br>
Пожалуй,  это всё, что можно сказать о поиске по инкременту. Чтобы его  протестировать, кликните по VT и начните нажимать разнообразные  сочетания клавиш.<br>
<br>
<b>2.3.6. Простейшие приёмы отрисовки.</b><br>
Что Я там ещё обещал? Ах, да! Отрисовка элементов. Вот два примера как можно скрасить чёрно-белые будни VT.<br>
<br>
Меняем цвет текста: </div><pre class="brush: pascal">	
procedure TfrmMain.VTPaintText(Sender: TBaseVirtualTree;
  const TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  TextType: TVSTTextType);
var
  PhoneNode: PPhoneNode;
begin
  PhoneNode := VT.GetNodeData(Node);
  if Assigned(PhoneNode) then
    TargetCanvas.Font.Color := PhoneNode^.Fg;
  if (vsSelected in Node.States) and (Sender.Focused) then
    TargetCanvas.Font.Color := clHighlightText;
end;</pre><br>
И фон узла:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.VTBeforeCellPaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  CellRect: TRect);
var
  PhoneNode: PPhoneNode;
begin
  PhoneNode := VT.GetNodeData(Node);
  if Assigned(PhoneNode) then
    with TargetCanvas do
    begin
      Brush.Color := PhoneNode^.Bg;
      FillRect(CellRect);
    end;
end;</pre><br>
А вот так можно на фоне нарисовать что-то наподобие Windows XP заголовка:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.VTBeforeCellPaint(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; Column: TColumnIndex;
  CellRect: TRect);
var
  BigGrad, SmallGrad: TRect;
begin
  if Column = 0 then
  begin
    BigGrad := CellRect;
    Dec(BigGrad.Bottom, 2);
    SmallGrad := BigGrad;
    SmallGrad.Top := SmallGrad.Bottom;
    Inc(SmallGrad.Bottom, 2);
    GradFill(TargetCanvas.Handle, BigGrad, clInactiveCaptionText, clWindow, gkHorz);
    GradFill(TargetCanvas.Handle, SmallGrad, clHighlight, clWindow, gkHorz);
  end;
end;</pre><br>
&nbsp; Процедуру градиентной заливки можно взять из всё того же проекта Figure 1.2. Берите, не стесняйтесь.<br>
<br>
<b>2.3.7. Рекурсивный перебор всех узлов дерева.</b><br>
Последний пример данной главы демонстрирует перебор всех узлов VT. </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.BtnFindClick(Sender: TObject);
  function FindNode(ANode: PVirtualNode;
    const APattern: WideString): PVirtualNode;
  var
    NextNode: PVirtualNode;
    PhoneNode: PPhoneNode;
  begin
    Result := nil;
    NextNode := ANode.FirstChild;
    if Assigned(NextNode) then
      repeat
        PhoneNode := VT.GetNodeData(NextNode);
        if Assigned(PhoneNode) then
          if RbName.Checked then
            if PhoneNode^.Name = APattern then
            begin
              Result := NextNode;
              Exit;
            end
            else
          else
            if PhoneNode^.Mobile = APattern then
            begin
              Result := NextNode;
              Exit;
            end;
        // Ищем в дочерних ветках
        Result := FindNode(NextNode, APattern);
        // Переходим на соседнюю ветку...
        NextNode := NextNode.NextSibling;
      until
        //...пока не вмажемся лбом в стену :)
        NextNode = nil;
  end;
var
  FoundNode: PVirtualNode;
begin
  if VT.RootNodeCount &gt; 0 then
  begin
    FoundNode := FindNode(VT.RootNode, EdSearch.Text);
    LoadNode(FoundNode);
    if Assigned(FoundNode) then
    begin
      VT.ClearSelection;
      VT.FocusedNode := FoundNode;
      Include(VT.FocusedNode.States, vsSelected);
    end;
  end;
end;</pre><br>
<br>
Здесь  становится заметно ещё одно маленькое неудобство. В связи с тем, что VT  работает со связанными списками, Вы не сможете использовать для  переборки цикл for. Остаются лишь циклы с проверкой наверху (<b>while</b>) и внизу (<b>repeat</b>..<b>until</b>).<br>
<br>
<i>Проект Figure 1.2, демонстрирующий работу с наиболее часто используемыми событиями VT находится в папке Fig 1.2.</i><br>
<br>
В  этой сравнительно большой главе мы разобрались с наиболее часто  используемыми событиями и методами VT. Но это ещё далеко не конец. Далее  мы ещё больше углубимся в недра VT и реализуем более сложные вещи,  такие как Drag&amp;Drop, взаимодействие с шеллом, работа с буфером  обмена и сохранение и загрузка дерева из внешних источников.<br>
<br>
<b>Добавлено @ 00:34</b><br>
<b>3.0. Принципы реализации Drag&amp;Drop, взаимодействие с шеллом, работа с буфером обмена.</b><br>
Бесспорно,  на лавры одной из самых удобных возможностей интерфейса, которая  когда-либо была изобретена, имеет все основания претендовать  Drag&amp;Drop (за исключением, пожалуй, двойного клика&nbsp;<img alt="smile" src="./Статья_files/smile_002.gif">),  позволяющая выполнить многие операции без клавиатуры простыми  манипуляциями мышкой. И бесспорно, она же и самая нетривиальная в  реализации задача. VT в этом плане не исключение. Несмотря на то, что в  компоненте максимально возможно реализована поддержка Drag&amp;Drop  различными событиями, свойствами и интерфейсами, нам придётся делать  основную часть работы самим.<br>
<br>
<b>3.1. Подходы к реализации Drag&amp;Drop.</b><br>
VT позволяет реализовать Drag&amp;Drop двумя базовыми подходами (свойство DragType):<br>
<ul><li><b>dtOLE</b>&nbsp;–  основан на системных методах и функциях, работает через ActiveX.  Настоятельно рекомендуется к использованию, т.к. полностью  поддерживается Windows и позволяет реализовать больше возможностей с  минимумом проблем. Работает через Windows-интерфейсы IDataObject,  IDragManager и т.д.</li>
<li><b>dtVCL</b>&nbsp;– подход, навязанный  Borland специально ради облегчения проектирования кроссплатформенных  приложений. Про него можно точно сказать: одно лечит, а другое калечит.  Главный его недостаток в том, что получатель должен иметь как можно  более полные сведения об отправителе и его данных. Таким образом, в нём  отсутствует поддержка Drag&amp;Drop между приложениями. Всё будет  происходить только в контексте Вашей программы. В ряде случаев это  заставляет писать прорву кода только для того, чтобы отделить один класс  от другого. Я уже и не говорю о возможностях их кардинального различия.  Старайтесь избегать VCL подход. Он теоретически и не является  Drag&amp;Drop вовсе.</li>
</ul><br>
Думаю, следует побольше сказать о выборе из этих двух методов.<br>
<b>OLE</b>&nbsp;позволяет  получать данные из любых приложений, в том числе и из своего. Причём VT  при использовании&nbsp;&nbsp;OLE способен также получать данные и из  VCL контролов Delphi, обученных только VCL Drag&amp;Drop от Borland.<br>
<b>VCL</b>&nbsp;позволяет  VT общаться только с контролами, которые используют VCL подход. Но это,  тем не менее, не значит, что VT не будет способен работать с OLE  данными, если ему выставить dtVCL свойство.<br>
Тогда зачем этот параметр&nbsp;<b>DragType</b>&nbsp;вообще, спросите Вы, если он всё равно ничего не меняет? Сейчас всё станет ясно.<br>
<br>
<b>3.2. Опция toAcceptOLEDrop.</b><br>
Данный  сеттинг находится в TreeOptions.MiscOptions. Он как раз и позволяет  разрешить или запретить вставку OLE данных. Если опция отключена, то  дерево с&nbsp;<b>dtOLE</b>&nbsp;параметром вообще перестанет воспринимать Drag&amp;Drop, тогда как&nbsp;<b>dtVCL</b>-дерево  будет ещё способно к VCL Drag&amp;Drop в Вашем приложении. Если же  опция включена, то дерево будет способно работать с любым типом  Drag&amp;Drop. Всё это станет Вам ещё более понятно, когда мы напишем  пример, который, кстати, будет поддерживать оба этих подхода.<br>
<br>
<b>3.3. Параметры Drag&amp;Drop.</b><br>
Помимо&nbsp;<b>DragType</b>, VT позволяет указать различные параметры операции. Рассмотрим их:<br>
<ul><li><b>ClipboardFormats</b>&nbsp;– содержит список форматов, распознаваемых VT для&nbsp;<b>OLE</b>&nbsp;метода (В VCL всё придётся делать ручками). Как минимум, должен быть включён Plain Text и Virtual Tree Data.</li>
<li><b>DefaultPasteMode</b>&nbsp;– положение вставляемой ветки по умолчанию.</li>
<li><b>DragWidth</b>,&nbsp;<b>DragHeight</b>&nbsp;–  размеры прозрачной картинки, отображающей краткое содержимое  перетаскиваемых объектов. Чем больше размер, тем больше потребуется  мощности процессора для обсчёта прозрачности.</li>
<li><b>DragImageKind</b>&nbsp;– позволяет указать будут ли в прозрачной картинке отображаться картинки узлов VT.</li>
<li><b>DragMode</b>&nbsp;–  перетаскивание начнётся автоматически при dmAutomatic или потребует  ручного управления при dmManual. Только не подумайте, что dmAutomatic  всё сделает за Вас&nbsp;<img alt="smile" src="./Статья_files/smile_002.gif">&nbsp;Нет, этот режим часто применяется вместе с методом OLE, тогда как dmManual предназначен для VCL метода.</li>
<li><b>DragOperations</b>&nbsp;– перечень операций для работы с Drag&amp;Drop.</li>
</ul><br>
<b>3.4. События Drag&amp;Drop.</b><br>
Вот они:<br>
<ul><li><b>OnCreateDataObject</b>&nbsp;– вызывается, когда drag manager’у необходим экземпляр класса TDataObject с заполненными полями.</li>
<li><b>OnCreateDragManager</b>&nbsp;–  позволяет пользователю создавать свои собственные drag manager’ы для  дерева. К сожалению, Я не имею опыта работы с этим сообщением.</li>
<li><b>OnGetUserClipboardFormats</b>&nbsp;– позволяет заполнить массив форматами данных, которые Вы способны обрабатывать. Используется совместно с OnRenderOLEData.</li>
<li><b>OnRenderOLEData</b>&nbsp;– используется для обработки данных, которые не поддерживаются встроенным обработчиком VT.</li>
<li><b>OnDragAllowed</b>&nbsp;– позволяет разрешить или запретить перетаскивание элементов.</li>
<li><b>OnDragDrop</b>&nbsp;– основное событие, происходит непосредственно после того, как была отпущена кнопка мыши и были получены данные.</li>
<li><b>OnDragOver</b>&nbsp;– происходит при наведении указателя на элемент дерева. Позволяет разрешить или запретить перетаскивание в этот элемент.</li>
<li><b>OnEndDrag</b>&nbsp;– Событие, следующее после OnDragDrop. Оповещает об окончательном завершении операции.</li>
<li><b>OnStartDrag</b>&nbsp;– оповещает о начале перетаскивания.</li>
<li><b>OnNodeCopied</b>&nbsp;– событие, связанное с CopyToClipboard/CutToClipboard методами дерева. Происходит сразу после копирования узла.</li>
<li><b>OnNodeCopying</b>&nbsp;– аналогично предыдущему, но происходит до вышеупомянутых методов и позволяет также запретить копирование.</li>
</ul><br>
<b>3.5. Пишем Drag&amp;Drop приложение с VT.</b><br>
Мы  подошли к решающему шагу – написанию своего первого Drag&amp;Drop  приложения с VT. Я решил в этом примере одновременно показать реализацию  не только Drag&amp;Drop, но и вставки из буфера обмена и работы с  шеллом одновременно. Почему Я смешал всё в одну кашу? Дело в том, что в  VT имеется собственный механизм для копирования и вставки своих узлов.  Но что если в буфере обмена не узлы VT, а какие-то другие данные? Тогда  вставку можно будет организовать через Drag&amp;Drop интерфейсы, что мы и  сделаем.<br>
<br>
Нам понадобятся:<br>
<ul><li>Дерево VT с dtOLE и dmAutomatic свойствами.</li>
<li>Дерево VT с VCL и dmManual свойствами.</li>
<li>RichEdit в качестве источника OLE Drag&amp;Drop данных.</li>
<li>ListBox в качестве источника VCL Drag&amp;Drop данных. Не забудьте также выставить ему dmAutomatic свойство.</li>
<li>У обоих VT-деревьев установите все ClipboardFormats в True.</li>
<li>Желательно также включить&nbsp;<b>toMultiSelect</b>&nbsp;в TreeOptions.SelectionOptions, чтобы можно было выделять несколько узлов разом.</li>
<li>3 действия (<b>TAction</b>)  для копирования, вырезания и вставки. Не забудьте им выставить  соответствующие Shortcut, чтобы можно было вызывать их прямо с  клавиатуры без всяких меню и кнопок.</li>
</ul><br>
Данные узла возьмём самые маленькие, чтобы не отвлекаться на лишнее: </div><br>
<pre class="brush: pascal">	
type
  PItemNode = ^TItemNode;
  TItemNode = record
    Name: WideString;
  end;</pre><br>
Заполняем контролы:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.FormCreate(Sender: TObject);
var
  i: Integer;
begin
  VT.NodeDataSize := SizeOf(TItemNode);
  VT2.NodeDataSize := SizeOf(TItemNode);
  VT.RootNodeCount := 30;
  VT2.RootNodeCount := 30;
  RichEdit.Lines.LoadFromFile('rtf.rtf');
  for i := 0 to 9 do
    ListBox.Items.Add(Format('String %d', [i]));
end;</pre><br>
Заметили,  что мы в вышеприведённом коде не заполнили узлы никакими данными? До  этого мы в цикле обрабатывали каждый узел. На этот раз Я решил показать  пример работы с ещё одним полезным событием VT –&nbsp;<b>OnInitNode</b>.  Оно позволяет заполнить узел данными, если Вы не сделали этого при  создании. Помимо этого, Вам будет также предложено задать различные  свойства для узла. В нашем случае обработчик этого события для обоих  деревьев будет выглядить так: </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTInitNode(Sender: TBaseVirtualTree; ParentNode,
  Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates);
var
  ItemNode: PItemNode;
begin
  ItemNode := Sender.GetNodeData(Node);
  if Assigned(ItemNode) then
    if Length(ItemNode^.Name) = 0 then
      ItemNode^.Name := 'Node Index № ' + IntToStr(Node.Index);
end;
</pre><br>
Как видите, в нашем случае гораздо удобнее использовать именно это событие, нежели делать всё непосредственно при создании узлов. Ведь все нам необходимые данные (индекс узла) мы получаем, не отходя от кассы, прямо на месте. Данное событие не является обязательным. Впредь Вы вольны будете решать, какой подход Вам будет удобнее.<br>
<br>
Следующие два обработчика Вам уже знакомы, назначьте их обоим деревьям:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.VTGetText(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; TextType: TVSTTextType; var CellText: WideString);
var
  ItemNode: PItemNode;
begin
  ItemNode := Sender.GetNodeData(Node);
  if Assigned(ItemNode) then
    CellText := ItemNode^.Name;
end;
</pre><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTNewText(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; NewText: WideString);
var
  ItemNode: PItemNode;
begin
  ItemNode := Sender.GetNodeData(Node);
  if Assigned(ItemNode) then
    ItemNode^.Name := NewText;
end;
</pre><br>
Вот так выглядят обработчики копирования и вырезания для действий из&nbsp;<b>TActionList</b>: </div><pre class="brush: pascal">	
procedure TfrmMain.BtnCopyClick(Sender: TObject);
begin
  if ActiveControl = VT then
    VT.CopyToClipBoard
  else if ActiveControl = VT2 then
    VT2.CopyToClipBoard
  else if ActiveControl = RichEdit then
    RichEdit.CopyToClipboard;
end;
</pre><br>
<pre class="brush: pascal">	
procedure TfrmMain.BtnCutClick(Sender: TObject);
begin
  if ActiveControl = VT then
    VT.CutToClipBoard
  else if ActiveControl = VT2 then
    VT2.CutToClipBoard
  else if ActiveControl = RichEdit then
    RichEdit.CutToClipBoard;
end;
</pre><br>
А вот процедура вставки уже будет различаться. Помните, Я говорил, что вставку OLE данных мы сделаем через те же интерфейсы, что и Drag&amp;Drop? Вот что у нас получится:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.BtnPasteClick(Sender: TObject);
var
  DataObject: IDataObject;
  EnumFormat: IEnumFormatEtc;
  Format: TFormatEtc;
  Formats: TFormatArray;
  Fetched: Integer;
  Tree: TVirtualStringTree;
begin
  if ActiveControl is TVirtualStringTree then
  begin
    Tree := ActiveControl as TVirtualStringTree;
    // Попробуем сначала вставить данные простым методом VT.
    if not Tree.PasteFromClipboard then
    begin
      // Если VT сам не смог справиться со вставкой, значит пришли данные
      // несколько другого типа, чем просто TVirtualNode узлы.
      // Это может быть, к примеру, текст или картинка.
      // Сейчас мы это узнаем, покопавшись в форматах буфера обмена.
      OLEGetClipboard(DataObject);
      // Получить список доступных в буфере обмена форматов в массив Formats.
      if Succeeded(DataObject.EnumFormatEtc(DATADIR_GET, EnumFormat)) then
      begin
        EnumFormat.Reset;
        while EnumFormat.Next(1, Format, @Fetched) = S_OK do
        begin
          SetLength(Formats, Length(Formats) + 1);
          Formats[High(Formats)] := Format.cfFormat;
        end;
        InsertData(Tree, DataObject, Formats, DROPEFFECT_COPY, Tree.DefaultPasteMode);
      end;
    end;
  end
  else if ActiveControl is TRichEdit then
    RichEdit.PasteFromClipboard;
end;
</pre><br>
Теперь  следуют собственно обработчики Drag&amp;Drop. Все комментарии Я  поместил в код. Для обоих деревьев два одинаковых обработчика.&nbsp;<b>onDragDrop</b>&nbsp;и&nbsp;<b>onDragOver</b>: </div><br>
<pre class="brush: pascal">	
//---------------------------------------------------------------------------
// На нас что-то кинули…
//---------------------------------------------------------------------------
procedure TfrmMain.VTDragDrop(Sender: TBaseVirtualTree; Source: TObject;
  DataObject: IDataObject; Formats: TFormatArray; Shift: TShiftState;
  Pt: TPoint; var Effect: Integer; Mode: TDropMode);
  // Определяем как поступать с данными. Перемещать, копировать или ссылаться
  procedure DetermineEffect;
  begin
    // Нажаты ли какие-нибудь управляющие клавиши?
    if Shift = [] then
    begin
      // Неа, не нажаты
      // Тогда, если отправитель и получатель - одинаковые объекты (например,
      // если узлы перемещаются из одного и того же дерева), то
      // надо переместить узлы, в противном случае - копировать.
      if Source = Sender then
        Effect := DROPEFFECT_MOVE
      else
        Effect := DROPEFFECT_COPY;
    end
    else begin
      // Нажаты. В зависмости от комбинации решаем что делать
      if (Shift = [ssAlt]) or (Shift = [ssCtrl, ssAlt]) then
        Effect := DROPEFFECT_LINK
      else
        if Shift = [ssCtrl] then
          Effect := DROPEFFECT_COPY
        else
          Effect := DROPEFFECT_MOVE;
    end;
  end;
var
  Attachmode: TVTNodeAttachMode;
  Nodes: TNodeArray;
  i: Integer;
begin
  Nodes := nil;
  // Определяем, куда добавлять узел в зависимости от того, куда была
  // брошена ветка.
  case Mode of
    dmAbove:
      AttachMode := amInsertBefore;
    dmOnNode:
      AttachMode := amAddChildLast;
    dmBelow:
      AttachMode := amInsertAfter;
  else
    AttachMode := amNowhere;
  end;
  if DataObject = nil then
  begin
    // Если не пришло интерфейса, то вставка проходит через VCL метод
    if Source is TVirtualStringTree then
    begin
      // Вставка из VT. Можем спокойно пользоваться его методами
      // копирования и перемещения.
      DetermineEffect;
      // Получаем список узлов, которые будут участвовать в Drag&amp;Drop
      Nodes := VT2.GetSortedSelection(True);
      // И работаем с каждым
      if Effect = DROPEFFECT_COPY then
      begin
        for i := 0 to High(Nodes) do
          VT2.CopyTo(Nodes[i], Sender.DropTargetNode, AttachMode, False);
      end
      else
        for i := 0 to High(Nodes) do
          VT2.MoveTo(Nodes[i], Sender.DropTargetNode, AttachMode, False);
    end
    else if Source is TListBox then
    begin
      // Вставка из объекта какого-то другого класса
      AddVCLText(Sender as TVirtualStringTree,
        (Source as TListBox).Items.Strings[(Source as TListBox).ItemIndex],
        AttachMode);
    end;
  end
  else begin
    // OLE drag&amp;drop.
    // Effect нужен для передачи его источнику drag&amp;drop, чтобы тот решил
    // что он будет делать со своими перетаскиваемыми данными.
    // Например, при DROPEFFECT_MOVE (перемещение) их нужно будет удалить,
    // при копировании - сохранить.
    if Source is TBaseVirtualTree then
      DetermineEffect
    else begin
      if Boolean(Effect and DROPEFFECT_COPY) then
        Effect := DROPEFFECT_COPY
      else
        Effect := DROPEFFECT_MOVE;
    end;
    InsertData(Sender as TVirtualStringTree, DataObject, Formats, Effect, AttachMode);
  end;
end;
//---------------------------------------------------------------------------
// В этом событии мы должны проверить есть ли среди перетаскиваемых веток
// родитель ветки, в которую происходит перетаскивание. Ведь нельзя
// же ветку-родитель перетащить в её дочерние элементы :)
//---------------------------------------------------------------------------
procedure TfrmMain.VTDragOver(Sender: TBaseVirtualTree; Source: TObject;
  Shift: TShiftState; State: TDragState; Pt: TPoint; Mode: TDropMode;
  var Effect: Integer; var Accept: Boolean);
  // Возвращает True, если AParent - дочерний узел ANode.
  function IsNodeParent(AParent, ANode: PVirtualNode): Boolean;
  var
    NextParent: PVirtualNode;
  begin
    NextParent := AParent;
    repeat
      NextParent := NextParent.Parent;
    until
      (NextParent = Sender.RootNode) or (NextParent = nil) or
        (NextParent = ANode);
    Result := ANode = NextParent;
  end;
var
  i: Integer;
  Nodes: TNodeArray;
begin
  Accept := True;
  if (Assigned(Sender.DropTargetNode)) and
    (Sender.DropTargetNode &lt;&gt; Sender.RootNode) then
    Nodes := (Sender as TVirtualStringTree).GetSortedSelection(True);
  if Length(Nodes) &gt; 0 then
  begin
    for i := 0 to Length(Nodes) - 1 do
    begin
      Accept :=
        // Узел не должен быть родителем ветки, в которую производится
        // вставка
        (not IsNodeParent(Sender.DropTargetNode, Nodes[i]))
        // Также, узел не должен равняться ветке-местоназначению вставки.
        // Т.е. мы должны запретить вставку узла в самого себя.
        and (not(Sender.DropTargetNode = Nodes[i]));
      // Отключаем вставку, если хотя бы одно из условий вернуло False
      if not Accept then
        Exit;
    end;
  end;
end;
</pre><br>
Этот обработчик&nbsp;<b>onDragAllowed</b>&nbsp;назначьте только дереву с VCL Drag&amp;Drop: </div><pre class="brush: pascal">	
procedure TfrmMain.VTDragAllowed(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; var Allowed: Boolean);
begin
  Allowed := True;
end;
</pre><br>
Метод&nbsp;<b>InsertData</b>&nbsp;предназначен  непосредственно для вставки новых OLE данных в дерево после того, как  мы их получили. Он будет искать среди полученных форматов тот, который  способен обработать. В нашем случае это ЮНИКОД-текст и файлы, брошенные  на нас из Explorer’a. Вот как он выглядит: </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.InsertData(Sender: TVirtualStringTree;
  DataObject: IDataObject; Formats: TFormatArray;
  Effect: Integer; Mode: TVTNodeAttachMode);
var
  FormatAccepted: Boolean; // True, если принятые данные уже обработались
  i: Integer;
begin
  // Ищем в переданных форматах тот, который можем обработать
  FormatAccepted := False;
  for i := 0 to High(Formats) do
  begin
    case Formats[i] of
      CF_HDROP: // Прибыл список файлов из Explorer'a.
      begin
        if not FormatAccepted then
        begin
          AddFile(DataObject, Sender as TVirtualStringTree, Mode);
          FormatAccepted := True;
        end;
      end;
      CF_UNICODETEXT: // ЮНИКОД-текст
      begin
        if not FormatAccepted then
        begin
          AddUnicodeText(DataObject, Sender as TVirtualStringTree, Mode);
          FormatAccepted := True;
        end;
      end;
      else if Formats[i] = CF_VIRTUALTREE then
      // Родной формат VT. Обрабатывает вставку своих же
      // TVirtualNode-узлов.
      begin
        if not FormatAccepted then
        begin
          Sender.ProcessDrop(DataObject, Sender.DropTargetNode, Effect, Mode);
          FormatAccepted := True;
        end;
      end;
    end;
  end;
end;
</pre><br>
Теперь посмотрим, как выглядят процедуры&nbsp;<b>AddVCLText</b>,&nbsp;<b>AddFile</b>&nbsp;и&nbsp;<b>AddUnicodeText</b>.  Все они предназначены для обработки какого-то одного типа пришедших  данных. Вот обработчики каждого из них с подробным описанием каждого  действия:<br>
<br>
</div><pre class="brush: pascal">	
//---------------------------------------------------------------------------
// Метод предназначен для обработки ЮНИКОД-текста, хранящегося в буфере
// обмена.
// Хранимый текст получается и разделяется на линии, которые затем
// вставляются в дерево в качестве новых узлов.
//---------------------------------------------------------------------------
procedure TfrmMain.AddUnicodeText(DataObject: IDataObject;
  Target: TVirtualStringTree; Mode: TVTNodeAttachMode);
var
  // Структура, которая будет запрашивать указатеь на глобальные данные
  FormatEtc: TFormatEtc;
  // Структура с данными
  Medium: TStgMedium;
  // Указатель на строку
  OLEData,
  // Для прохода цикла с целью разделения текста на строки
  Head, Tail: PWideChar;
  // Узел, получающий новую ветку
  TargetNode,
  // Новая ветка
  Node: PVirtualNode;
  // Её данные
  Data: PItemNode;
begin
  if Mode &lt;&gt; amNowhere then
  begin
    // Заполняем струкутру для получения ЮНИКОД-текста
    with FormatEtc do
    begin
      cfFormat := CF_UNICODETEXT;
      // Нет у нас никакого девайса...
      ptd := nil;
      // Нам нужно содержание (текст в данном случае)
      dwAspect := DVASPECT_CONTENT;
      // Нет страницы для мультистраничных данных
      lindex := -1;
      // Мы будем получать указатель на данные через глобальную память
      tymed := TYMED_HGLOBAL;
    end;
    // Есть ли ЮНИКОД-текст для нашего запроса?
    if DataObject.QueryGetData(FormatEtc) = S_OK then
    begin
      // Опа, есть, можем получить данные
      if DataObject.GetData(FormatEtc, Medium) = S_OK then
      begin
        // Вот они:
        OLEData := GlobalLock(Medium.hGlobal);
        if Assigned(OLEData) then
        begin
          Target.BeginUpdate;
          // Выбираем место для вставки, если переданное = nil
          TargetNode := Target.DropTargetNode;
          if TargetNode = nil then
            TargetNode := Target.FocusedNode;
          // Разбиваем текст на строки
          Head := OLEData;
          try
            while Head^ &lt;&gt; #0 do
            begin
              Tail := Head;
              while not (Tail^ in [WideChar(#0), WideChar(#13), WideChar(#10), WideChar(#9)]) do
                Inc(Tail);
              if Head &lt;&gt; Tail then
              begin
                // Добавляем новую ноду, если есть хотя бы один символ
                // для строки.
                Node := Target.InsertNode(TargetNode, Mode);
                Data := Target.GetNodeData(Node);
                Data^.Name := Head;
                SetLength(Data^.Name, (Tail - Head));
              end;
              // Пропускаем табы
              if Tail^ = #9 then
                Inc(Tail);
              // Символы переноса каретки и конца строки
              if Tail^ = #13 then
                Inc(Tail);
              if Tail^ = #10 then
                Inc(Tail);
              // Шагаем дальше
              Head := Tail;
            end;
          finally
            GlobalUnlock(Medium.hGlobal);
            Target.EndUpdate;
          end;
        end;
        // Вот это лучше не забывать делать
        ReleaseStgMedium(Medium);
      end;
    end;
  end;
end;
//---------------------------------------------------------------------------
// Получение имён файлов, брошенных на нас из Explorer’а
//---------------------------------------------------------------------------
procedure TfrmMain.AddFile(DataObject: IDataObject;
  Target: TVirtualStringTree; Mode: TVTNodeAttachMode);
var
  FormatEtc: TFormatEtc;
  Medium: TStgMedium;
  OLEData: PDropFiles;
  Files: PChar;
  Str: String;
  TargetNode,
  Node: PVirtualNode;
  Data: PItemNode;
begin
  if Mode &lt;&gt; amNowhere then
  begin
    // На этот раз нас интересует есть ли в буфере CF_HDROP формат
    with FormatEtc do
    begin
      cfFormat := CF_HDROP;
      ptd := nil;
      dwAspect := DVASPECT_CONTENT;
      lindex := -1;
      tymed := TYMED_HGLOBAL;
    end;
    if DataObject.QueryGetData(FormatEtc) = S_OK then
    begin
      if DataObject.GetData(FormatEtc, Medium) = S_OK then
      begin
        OLEData := GlobalLock(Medium.hGlobal);
        if Assigned(OLEData) then
        begin
          Target.BeginUpdate;
          TargetNode := Target.DropTargetNode;
          if TargetNode = nil then
            TargetNode := Target.FocusedNode;
          try
            // А вот с этим Я долго мучался. В Microsoft зажрались и не дали
            // примера работы с DROPFILES структурой.
            // Оказывается, список брошенных файлов хранится в адресе
            // структуры
            // + offset, который и есть OLEData^.pFiles.
            Files := PChar(OLEData) + OLEData^.pFiles;
            // Список оканчивается двойным null символом
            while Files^ &lt;&gt; #0 do
            begin
              if OLEData^.fWide then
              begin
                Str := PWideChar(Files);
                // +1 нужен для того, чтобы перешагнуть null символ одного
                // из имён файлов в списке
                Inc(Files, (Length(PWideChar(Files)) + 1)*SizeOf(WideChar));
              end
              else begin
                Str := Files;
                // Аналогчно
                Inc(Files, (Length(PChar(Files)) + 1)*SizeOf(Char));
              end;
              Node := Target.InsertNode(TargetNode, Mode);
              Data := Target.GetNodeData(Node);
              Data^.Name := Str;
            end;
          finally
            GlobalUnlock(Medium.hGlobal);
            Target.EndUpdate;
          end;
        end;
        ReleaseStgMedium(Medium);
      end;
    end;
  end;
end;
//---------------------------------------------------------------------------
// Метод для получения строки из VCL контролов.
// Режем на линии.
//---------------------------------------------------------------------------
procedure TfrmMain.AddVCLText(Target: TVirtualStringTree;
  const Text: WideString; Mode: TVTNodeAttachMode);
var
  Head, Tail: PWideChar;
  TargetNode,
  Node: PVirtualNode;
  Data: PItemNode;
begin
  if Mode &lt;&gt; amNoWhere then
  begin
    Target.BeginUpdate;
    try
      TargetNode := Target.DropTargetNode;
      if TargetNode = nil then
        TargetNode := Target.FocusedNode;
      Head := PWideChar(Text);
      while Head^ &lt;&gt; #0 do
      begin
        Tail := Head;
        while not (Tail^ in [WideChar(#0), WideChar(#13), WideChar(#10), WideChar(#9)]) do
          Inc(Tail);
        if Head &lt;&gt; Tail then
        begin
          Node := Target.InsertNode(TargetNode, Mode);
          Data := Target.GetNodeData(Node);
          SetString(Data^.Name, Head, Tail - Head);
        end;
        if Tail^ = #9 then
          Inc(Tail);
        if Tail^ = #13 then
          Inc(Tail);
        if Tail^ = #10 then
          Inc(Tail);
        Head := Tail;
      end;
    finally
      Target.EndUpdate;
    end;
  end;
end;
</pre><br>
Всё!  Мы сделали это. Можете теперь скомпилировать пример и проверить его  работоспособность. В качестве теста, попробуйте копировать и вырезать  узлы, перемещать их между деревьями, перетаскивать текст из TRichEdit,  TListBox, MSWord, Visual Studio, Total Commander, выделите несколько  папок и файлов в Explorer и киньте их на деревья. Можете попробовать  взаимодействовать и с другими приложениями, а также перетаскивать узлы  из деревьев в TRichEdit или другие приложения. Всё в итоге должно  работать на ура. Почти всегда реализованных нами методов вполне хватает,  разве что обработку вставки графики мы не реализовали, но это можете  оставить уже себе в качестве тренировки&nbsp;<img alt="smile" src="./Статья_files/smile_002.gif">. Поздравляю, Ваше приложение полностью совместимо Drag&amp;Drop!<br>
<br>
<i>Проект Figure 1.3, демонстрирующий работу с Drag&amp;Drop находится в папке Fig 1.3.</i><br>
<br>
<b>Добавлено @ 00:35</b><br>
<b>4.0. Создание собственных редакторов данных. Работа с интерфейсом IVTEditLink.</b><br>
VT  предоставляет замечательную возможность создавать свои собственные  редакторы данных, кроме обычного текстового поля для редактирования  текста. Эту возможность можно использовать, чтобы облегчить пользователю  работу с какими-то специализированными данными. Например, при изменении  цвета можно использовать ComboBox со списком цветов, а при измени даты –  вызывать календарь. Конечно, это непременно прибавит профессиональности  вашей программе.<br>
Чтобы как-то обобщить редактирование различных  типов данных и позволить взаимодействовать редакторам дерева с  приложением, компонент использует интерфейс&nbsp;<b>IVTEditLink</b>. Давайте создадим небольшой пример, где постараемся реализовать собственные редакторы для различных типов данных.<br>
<br>
<b>4.1. Пишем класс, реализующий интерфейс IVTEditLink.</b><br>
<br>
Для  начала определимся, какие форматы данных, а следственно редакторы, мы  будем использовать в примере. Думаю, этого будет достаточно для начала: </div><br>
<pre class="brush: pascal">	
type
  TVTEditorKind = (
    ekString, // TEdit
    ekMemo, // TMemo
    ekComboBox, // TComboBox
    ekColor, // TColorBox
    ekDate, // TDateTimePicker
    ekMask, // TMaskedEdit
    ekProgress // TProgressBar
  );
</pre><br>
Мы напишем один класс для реализации интерфейса для каждого типа редактора. Это наиболее рациональный подход вместо того, чтобы для каждого редактора создавать свой класс, реализующий один и тот же интерфейс. Вот как он будет выглядеть:<br>
<pre class="brush: pascal">	
TVTCustomEditor = class(TInterfacedObject, IVTEditLink)
private
  FEdit: TWinControl;        // Базовый класс для каждого типа редактора
  FTree: TVirtualStringTree; // Ссылка на дерево, вызвавшее редактирование
  FNode: PVirtualNode;       // Редактируемый узел
  FColumn: Integer;          // Его колонка, в которой оно происходит
protected
  procedure EditKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
public
  destructor Destroy; override;
 
  function BeginEdit: Boolean; stdcall;
  function CancelEdit: Boolean; stdcall;
  function EndEdit: Boolean; stdcall;
  function GetBounds: TRect; stdcall;
  function PrepareEdit(Tree: TBaseVirtualTree; Node: PVirtualNode;
    Column: TColumnIndex): Boolean; stdcall;
  procedure ProcessMessage(var Message: TMessage); stdcall;
  procedure SetBounds(R: TRect); stdcall;
end;
</pre><br>
Как видите, все специализированные редакторы будут потомками TWinControl. С помощью типа TVTEditorKind мы будем определять, какой конкретно класс редактора будет создаваться. В комментариях, напротив полей перечисления, указан класс редактора для каждого поля.<br>
Теперь нам необходимо решить, как будет выглядеть структура данных для каждого узла. Нам необходимо где-то хранить строковую переменную, которая в соответствии с типом редактора будет трансформироваться в нужный тип данных, а также переменную типа TVTEditorKind, чтобы мы могли знать какой тип редактора будет создан для данного конкретного узла.<br>
Получаем:<br>
<br>
<pre class="brush: pascal">	
type
  PVTEditNode = ^TVTEditNode;
  TVTEditNode = record
    Kind: TVTEditorKind;
    Value: String;
    Changed: Boolean;
  end;
</pre><br>
00<br>
<br>
Сюда Я также добавил поле Changed, чтобы определить, что узел был отредактирован и не содержит больше своего значения по умолчанию. Это необязательный параметр.<br>
Наш пример будет содержать 2 колонки (параметр-значение) и 7 узлов для каждого типа редактора. Чтобы не отвлекаться и не писать лишнего кода, определим для данных 3 массива: типы редакторов для каждого из семи узлов, значения по умолчанию для поля Changed и текст для первой колонки.<br>
<pre class="brush: pascal">	
ValueTypes: array[0..6] of TVTEditorKind = (
    ekString, // Имя
    ekMemo, // Описание
    ekComboBox, // Тип
    ekColor, // Цвет
    ekDate, // Дата
    ekMask, // Маска
    ekProgress // Процесс
  );
  // Значения по умолчанию
  DefaultValues: array[0..6] of String = (
    'Свитер',
    'Мягкий и тёплый.',
    'Шерсть',
    'clRed',
    '24.06.2006',
    '798-77-66',
    '70 %'
  );
  // Имена параметров
  ValueNames: array[0..6] of String = (
    'Имя изделия',
    'Комментарий',
    'Материал',
    'Цвет изделия',
    'Дата изготовления',
    'Телефон склада',
    'Процесс доставки'
  );
</pre><br>
Всё, теперь можно приступать к написанию кода, реализующего методы нашего класса. По ходу работы Я старался давать максимально полные и понятные комментарии к каждому действию.<br>
<br>
<pre class="brush: pascal">	
//---------------------------------------------------------------------------
{* * * * * * * * * * * * * * * * TVTCustomEditor * * * * * * * * * * * * * *}
//---------------------------------------------------------------------------
destructor TVTCustomEditor.Destroy;
begin
  FreeAndNil(FEdit);
  inherited;
end;
//---------------------------------------------------------------------------
// Для обработки нажатий с клавиатуры.
// Отмена редактирования по Escape, завершение редактирования по Enter,
// и переход между узлами по Up/Down, если список элементов у комбо бокса или
// редактора даты не выпущен.
//---------------------------------------------------------------------------
procedure TVTCustomEditor.EditKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
var
  CanContinue: Boolean;
begin
  CanContinue := True;
  case Key of
    VK_ESCAPE: // Нажали Escape
      if CanContinue then
      begin
        FTree.CancelEditNode;
        Key := 0;
      end;
    VK_RETURN: // Нажали Enter
      if CanContinue then
      begin
        // Если Ctrl для TMemo не зажат, то завершаем редактирование
        // Сделаем так, чтобы можно было по Ctrl+Enter вставлять в Memo
        // новую линию.
        if (FEdit is TMemo) and (Shift = []) then
          FTree.EndEditNode
        else if not(FEdit is TMemo) then
          FTree.EndEditNode;
        Key := 0;
      end;
    VK_UP, VK_DOWN:
      begin
        // Проверить, не идёт ли работа с редактором. Если идёт, то запретить
        // активность дерева, если нет, то передать нажатие дереву.
        CanContinue := Shift = [];
        if FEdit is TComboBox then
          CanContinue := CanContinue and not TComboBox(FEdit).DroppedDown;
        if FEdit is TDateTimePicker then
          CanContinue := CanContinue and not TDateTimePicker(FEdit).DroppedDown;
        if CanContinue then
        begin
          // Передача клавиши дереву
          PostMessage(FTree.Handle, WM_KEYDOWN, Key, 0);
          Key := 0;
        end;
      end;
  end;
end;
//---------------------------------------------------------------------------
// Началось редактирование, нужно показать редактор и установить ему фокус
//---------------------------------------------------------------------------
function TVTCustomEditor.BeginEdit: Boolean;
begin
  Result := True;
  with FEdit do
  begin
    Show;
    SetFocus;
  end;
end;
//---------------------------------------------------------------------------
// Отменилось, прячем редактор
//---------------------------------------------------------------------------
function TVTCustomEditor.CancelEdit: Boolean;
begin
  Result := True;
  FEdit.Hide;
end;
//---------------------------------------------------------------------------
// Успешно завершилось, прячем редактор, обновляем данные узла и возвращаем
// фокус дереву
//---------------------------------------------------------------------------
function TVTCustomEditor.EndEdit: Boolean;
var
  Txt: String;
begin
  Result := True;
  if FEdit is TEdit then
    Txt := TEdit(FEdit).Text
  else if FEdit is TMemo then
    Txt := TEdit(FEdit).Text
  else if FEdit is TComboBox then
    Txt := TComboBox(FEdit).Text
  else if FEdit is TColorBox then
    Txt := ColorToString(TColorBox(FEdit).Selected)
  else if FEdit is TDateTimePicker then
  begin
    Txt := DateToStr(TDateTimePicker(FEdit).DateTime);
  end
  else if FEdit is TMaskEdit then
    Txt := TMaskEdit(FEdit).Text
  else if FEdit is TProgressBar then
    Txt := IntToStr(TProgressBar(FEdit).Position) + ' %';
  // Изменяем текст узла (поле Value у TVTEditNode) через событие OnNewText
  // у дерева
  FTree.Text[FNode, FColumn] := Txt;
  FEdit.Hide;
  FTree.SetFocus;
end;
//---------------------------------------------------------------------------
// Возвращаем границы редактора
//---------------------------------------------------------------------------
function TVTCustomEditor.GetBounds: TRect;
begin
  Result := FEdit.BoundsRect;
end;
//---------------------------------------------------------------------------
// В подготовке к редактированию мы должны создать экземпляр TWinControl
// нужного класса потомка в соответствии с полем Kind у TVTEditNode
//---------------------------------------------------------------------------
function TVTCustomEditor.PrepareEdit(Tree: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex): Boolean;
var
  VTEditNode: PVTEditNode;
begin
  Result := True;
  FTree := Tree as TVirtualStringTree;
  FNode := Node;
  FColumn := Column;
  FreeAndNil(FEdit);
  VTEditNode := FTree.GetNodeData(Node);
  case VTEditNode.Kind of
    ekString:
    begin
      FEdit := TEdit.Create(nil);
      with FEdit as TEdit do
      begin
        AutoSize := False;
        Visible := False;
        Parent := Tree;
        Text := VTEditNode.Value;
        OnKeyDown := EditKeyDown;
      end;
    end;
    ekMemo:
    begin
      FEdit := TMemo.Create(nil);
      with FEdit as TMemo do
      begin
        Visible := False;
        Parent := Tree;
        ScrollBars := ssVertical;
        Text := VTEditNode.Value;
        OnKeyDown := EditKeyDown;
      end;
    end;
    ekComboBox:
    begin
      FEdit := TComboBox.Create(nil);
      with FEdit as TComboBox do
      begin
        Visible := False;
        Parent := Tree;
        Text := VTEditNode.Value;
        Items.Add('Шерсть');
        Items.Add('Хлопок');
        Items.Add('Шёлк');
        Items.Add('Кожа');
        Items.Add('Велюр');
        OnKeyDown := EditKeyDown;
      end;
    end;
    ekColor:
    begin
      FEdit := TColorBox.Create(nil);
      with FEdit as TColorBox do
      begin
        Visible := False;
        Parent := Tree;
        Selected := StringToColor(VTEditNode.Value);
        Style := Style + [cbPrettyNames];
        OnKeyDown := EditKeyDown;
      end;
    end;
    ekMask:
    begin
      FEdit := TMaskEdit.Create(nil);
      with FEdit as TMaskEdit do
      begin
        AutoSize := False;
        Visible := False;
        Parent := Tree;
        EditMask := '999-99-99';
        Text := VTEditNode.Value;
        OnKeyDown := EditKeyDown;
      end;
    end;
    ekDate:
    begin
      FEdit := TDateTimePicker.Create(nil);
      with FEdit as TDateTimePicker do
      begin
        Visible := False;
        Parent := Tree;
        Date := StrToDate(VTEditNode.Value);
        OnKeyDown := EditKeyDown;
      end;
    end;
    ekProgress:
    begin
      FEdit := TProgressBar.Create(nil);
      with FEdit as TProgressBar do
      begin
        Visible := False;
        Parent := Tree;
        Position := StrToIntDef(VTEditNode.Value, 70);
      end;
    end
  else
    Result := False;
  end;
end;
//---------------------------------------------------------------------------
// Обработка сообщений Windows для редактора
//---------------------------------------------------------------------------
procedure TVTCustomEditor.ProcessMessage(var Message: TMessage);
begin
  FEdit.WindowProc(Message);
end;
//---------------------------------------------------------------------------
// Устанавливает границы редактора в соответствии с шириной и высотой колонки
//---------------------------------------------------------------------------
procedure TVTCustomEditor.SetBounds(R: TRect);
var
  Dummy: Integer;
begin
  FTree.Header.Columns.GetColumnBounds(FColumn, Dummy, R.Right);
  FEdit.BoundsRect := R;
  if FEdit is TMemo then
    FEdit.Height := 80;
end;
</pre><br>
Всё! Основную работу мы проделали. Настало время соединить наш класс с VT. Делается это передачей интерфейса в событии&nbsp;<b>OnCreateEditor</b>: </div><pre class="brush: pascal">	
procedure TfrmMain.VTCreateEditor(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; out EditLink: IVTEditLink);
begin
  EditLink := TVTCustomEditor.Create;
end;
</pre><br>
Суть его в простой передаче экземпляра нашего редактора. Теперь при начале редактирования VT будет вызывать методы нашего класса вместо своего стандартного редактора. Не забудьте обработать изменившиеся поля дерева:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.VTNewText(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; NewText: WideString);
var
  VTEditNode: PVTEditNode;
begin
  VTEditNode := Sender.GetNodeData(Node);
  with VTEditNode^ do
  begin
    if not Changed then
      Changed := Value &lt;&gt; NewText;
    Value := StringReplace(NewText, #13#10, ' ', [rfReplaceAll]);
  end;
end;
</pre><br>
Редактирование само по себе не включится. В событии&nbsp;<b>OnEditing</b>&nbsp;необходимо разрешить его: </div><pre class="brush: pascal">	
procedure TfrmMain.VTEditing(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; var Allowed: Boolean);
begin
  Allowed := Column &gt; 0;
end;
</pre><br>
Об  остальных событиях Вы можете сами позаботиться, благо знаний у Вас уже  достаточно. Включите свойство TreeOptions.MiscOptions.toEditable у VT и  запустите скомпилированное приложение. Каждый из семи узлов будет  обладать собственным редактором.<br>
<br>
Приведённый  пример предоставляет достаточный запас информации для начала написания  собственных элементов управления и внедрения их в VT. Вы имеете мощный  инструмент для редактирования узлов, границы которого ограничиваются  лишь вашей фантазией. В качестве домашнего задания можете попробовать  связать VT с числовым редактором.<br>
<br>
<i>Проект Figure 1.4, демонстрирующий работу со специализированными редакторами данных находится в папке Fig 1.4.</i><br>
<br>
<b>5.0. Полное изменение отрисовки дерева. Класс TVirtualDrawTree.</b><br>
Вэтой  главе мы с Вами рассмотрим работу с классом TVirtualDrawTree,  специально предназначенного для отрисовки нестандартных в отображении  узлов. Он не ориентирован на отображение каких-то специфических данных,  вроде текста. TVirtualDrawTree специально предназначен исключительно для  отрисовки различных элементов дизайна вашей программы. В нашем примере  мы рассмотрим создание полностью видоизменённого дерева, напоминающего  собой менеджер закачек Mozilla Firefox c отображением различных  элементов управления. Но для начала разберёмся в отличиях  TVirtualDrawTree от TVirtualStringTree, с которым мы ранее работали.<br>
<br>
<b>5.1. Отличительные черты класса TVirtualDrawTree.</b><br>
Различия  минимальны. Сразу бросается в глаза отсутствие привычных событий  OnGetText и OnNewText, что говорит о непредназначенности дерева для  работы с текстовыми данными. Тем не менее, Вы по-прежнему можете  использовать собственные редакторы, всё для этого на месте. Появилось  целых четыре новых события:<br>
<ul><li><b>OnDrawNode</b>&nbsp;– если у  TVirtualStringTree основа – событие OnGetText, то у TVirtualDrawTree это  OnDrawNode. В этом событии необходимо будет полностью реализовать всю  отрисовку узла.</li>
<li><b>OnGetNodeWidth</b>&nbsp;– предназначено для  указания ширины узла. Напомню, что высота узла указывается в параметре  DefaultNodeHeight для деревьев с узлами одинаковой высоты или в событии  OnMeasureItem для деревьев с узлами различной высоты.</li>
<li><b>OnGetHintSize</b>&nbsp;– предназначено для указания размеров всплывающей подсказку.</li>
<li><b>OnDrawHint</b>&nbsp;–  событие, позволяющее отрисовку всплывающей подсказки. До сих пор мы  могли лишь указать текст подсказки, но с этого момента мы должны будем  заниматься полным отображением подсказки самостоятельно.</li>
</ul>Всё остальное не претерпело никаких изменений.<br>
<br>
<b>5.2. Самостоятельное отображение узлов и их подсказок.</b><br>
В  тексте данной главы Я ограничился лишь указанием примерной реализации  событий OnDrawNode и OnDrawHint, а также реализацией потока. Всё  остальное в рамках данной главы довольно объёмно и не представляет для  нас большого интереса, поэтому, чтобы увидеть результат работы наших  трудов, необходимо скомпилировать пример из папки Fig 1.5.<br>
<br>
Предположим,  что нам необходимо создать небольшую базу данных заказов продуктового  магазина. Мы должны предусмотреть отображение картинок изделий, их  названий, цен и т.д. Также, нам необходимо визуализировать процесс  доставки какого-то заказа. Задание нетривиальное, но вполне реализуемое с  помощью TVirtualDrawTree.<br>
Как обычно, начинаем с продумывания структуры данных каждого узла: </div><br>
<pre class="brush: pascal">	
type
  PItemNode = ^TItemNode;
  TItemNode = record
    Image, Name: String;
    Mass, PriceKg: Word;
    Process: Byte;
    PersonalThread: Cardinal;
  end;
</pre><br>
Нам необходимо хранить путь к картинке, имя изделия, вес и цену за килограмм. Поле Process необходимо для имитации процесса доставки. Его значение мы будем изменять с помощью отдельного потока, а отображать с помощью TProgressBar в выделенном узле. Хендл потока будет храниться в поле PersonalThread.<br>
Переходим к реализации событий:<br>
<br>
<pre class="brush: pascal">	
//---------------------------------------------------------------------------
// Отрисовка всплывающей подсказки.
//---------------------------------------------------------------------------
procedure TfrmMain.VTDrawHint(Sender: TBaseVirtualTree; HintCanvas: TCanvas;
  Node: PVirtualNode; R: TRect; Column: TColumnIndex);
var
  NodeData: PItemNode;
  Th: Integer;
  ImgRect, RealRect, NameRect, PriceRect: TRect;
  Img: TPicture;
begin
  // Области отрисовки различных элементов
  Th := HintCanvas.TextHeight('Wj');
  RealRect := R;
  // Границы картинки
  ImgRect := RealRect;
  with ImgRect do
  begin
    Inc(Left, 16);
    Inc(Top, 8);
    Right := Left + 64;
    Bottom := Top + 64;
  end;
  // Границы текста наименования
  NameRect := RealRect;
  with NameRect do
  begin
    Inc(Left, 96);
    Inc(Top, 8);
    Bottom := Top + Th;
  end;
  // Границы текста общей цены
  PriceRect := RealRect;
  with PriceRect do
  begin
    Inc(Left, 96);
    Dec(Bottom, 16);
    Top := Bottom - Th;
  end;
  // Рисуем фон
  with HintCanvas do
  begin
    with Brush do
    begin
      Color := clInfoBk;
      Style := bsSolid;
    end;
    Pen.Color := clBlack;
    Pen.Width := 1;
    // Жёлтый фон и чёрная рамка по бокам
    Rectangle(RealRect);
  end;
  // Текст
  NodeData := Sender.GetNodeData(Node);
  with HintCanvas do
  begin
    Brush.Style := bsClear;
    Font.Color := clWindowText;
    // Наименование
    Font.Style := [fsBold];
    if NodeData^.Process = 0 then
      TextOut(NameRect.Left, NameRect.Top, NodeData^.Name + ' (не доcтавлено)')
    else if (NodeData^.Process &gt; 0) and (NodeData^.Process &lt; 100) then
      TextOut(NameRect.Left, NameRect.Top, NodeData^.Name + ' (доставляется)')
    else if NodeData^.Process = 100 then
      TextOut(NameRect.Left, NameRect.Top, NodeData^.Name + ' (доставлено)');
    // Общая цена
    Font.Style := [];
    TextOut(PriceRect.Left, PriceRect.Top, 'Общая цена: ' + IntToStr(NodeData^.PriceKg * NodeData^.Mass) + ' р.');
  end;
  // Картинка
  Img := TPicture.Create;
  try
    Img.LoadFromFile(NodeData^.Image);
    HintCanvas.Draw(ImgRect.Left, ImgRect.Top, Img.Graphic);
    with HintCanvas, ImgRect do
    begin
      Pen.Width := 2;
      Pen.Color := $00B99D7F;
      Rectangle(Rect(ImgRect.Left, Top, Left + Img.Width, Top + Img.Height));
    end;
  finally
    FreeAndNil(Img);
  end;
  // Отображаем процесс выполнения
  with FProgress do
  begin
    Position := NodeData^.Process;
    Width := RealRect.Right - 96 - 16;
    PaintTo(HintCanvas, NameRect.Left, NameRect.Top + Th + Th div 2);
  end;
end;
//---------------------------------------------------------------------------
// Отрисовка узла
//---------------------------------------------------------------------------
procedure TfrmMain.VTDrawNode(Sender: TBaseVirtualTree;
  const PaintInfo: TVTPaintInfo);
var
  NodeData: PItemNode;
  Th: Integer;
  ImgRect, RealRect, NameRect, GetRect, CancelRect, MassRect, PriceRect: TRect;
  Img: TPicture;
begin
  // Области отрисовки различных элементов
  Th := PaintInfo.Canvas.TextHeight('Wj');
  RealRect := PaintInfo.CellRect;
  ImgRect := RealRect;
  with ImgRect do
  begin
    Inc(Left, 16);
    Inc(Top, 16);
    Right := Left + 64;
    Bottom := Top + 64;
  end;
  NameRect := RealRect;
  with NameRect do
  begin
    Inc(Left, 96);
    Inc(Top, 16);
    Bottom := Top + Th;
  end;
  GetRect := RealRect;
  with GetRect do
  begin
    Dec(Bottom, 16 + Th);
    Top := Bottom - Th;
    Dec(Right, 16);
    Left := Right - PaintInfo.Canvas.TextWidth('Доставить');
  end;
  CancelRect := GetRect;
  with CancelRect do
  begin
    Inc(Top, Th);
    Inc(Bottom, Th);
  end;
  MassRect := RealRect;
  with MassRect do
  begin
    Inc(Left, 96);
    Dec(Bottom, 16 + Th);
    Top := Bottom - Th;
  end;
  PriceRect := MassRect;
  with PriceRect do
  begin
    Inc(Top, Th);
    Inc(Bottom, Th);
  end;
  // Рисуем фон
  with PaintInfo.Canvas do
  begin
    with Brush do
    begin
      Color := clWindow;
      Style := bsSolid;
    end;
    Pen.Color := $00B99D7F;
  end;
  if PaintInfo.Node = Sender.FocusedNode then
    GradFill(PaintInfo.Canvas.Handle, RealRect, $00EAE2D9, $00D7C8B7, gkVert)
  else
    PaintInfo.Canvas.FillRect(RealRect);
  // Текст
  NodeData := Sender.GetNodeData(PaintInfo.Node);
  with PaintInfo.Canvas do
  begin
    Brush.Style := bsClear;
    Font.Color := clWindowText;
    // Наименование
    Font.Style := [fsBold];
    if NodeData^.Process = 0 then
      TextOut(NameRect.Left, NameRect.Top, NodeData^.Name + ' (не доcтавлено)')
    else if (NodeData^.Process &gt; 0) and (NodeData^.Process &lt; 100) then
      TextOut(NameRect.Left, NameRect.Top, NodeData^.Name + ' (доставляется)')
    else if NodeData^.Process = 100 then
      TextOut(NameRect.Left, NameRect.Top, NodeData^.Name + ' (доставлено)');
    // Масса
    Font.Style := [];
    TextOut(MassRect.Left, MassRect.Top, 'Масса: ' + IntToStr(NodeData^.Mass) + ' кг.');
    // Цена
    TextOut(PriceRect.Left, PriceRect.Top, 'Цена за килограмм: ' + IntToStr(NodeData^.PriceKg) + ' р.');
    // Доставить
    with Font do
    begin
      Style := [fsUnderline];
      Color := clBlue;
    end;
    TextOut(GetRect.Left, GetRect.Top, 'Доставить');
    // Отмена
    TextOut(CancelRect.Left, CancelRect.Top, 'Отмена');
  end;
  // Картинка
  Img := TPicture.Create;
  try
    Img.LoadFromFile(NodeData^.Image);
    PaintInfo.Canvas.Draw(ImgRect.Left, ImgRect.Top, Img.Graphic);
    if PaintInfo.Node = Sender.FocusedNode then
      with PaintInfo.Canvas, ImgRect do
      begin
        Pen.Width := 2;
        Rectangle(Rect(ImgRect.Left, Top, Left + Img.Width, Top + Img.Height));
      end;
  finally
    FreeAndNil(Img);
  end;
  // Процесс
  if PaintInfo.Node = Sender.FocusedNode then
    with FProgress do
    begin
      Position := NodeData^.Process;
      Width := RealRect.Right - 96 - 16;
      PaintTo(PaintInfo.Canvas, NameRect.Left, NameRect.Top + Th + Th div 2);
    end;
end;
//---------------------------------------------------------------------------
// Метод предназначен для отображения курсора руки над надписями "Доставить"
// и "Отмена", которые нарисованы в стиле ссылок.
//---------------------------------------------------------------------------
procedure TfrmMain.VTGetCursor(Sender: TBaseVirtualTree; var Cursor: TCursor);
var
  Pt: TPoint;
  Node: PVirtualNode;
  NRect: TRect;
  D: Integer;
  Inf: tagScrollInfo;
begin
  GetCursorPos(Pt);
  Pt := Sender.ScreenToClient(Pt);
  Node := Sender.GetNodeAt(Pt.X, Pt.Y);
  with Inf do
  begin
    cbSize := SizeOf(tagScrollInfo);
    fMask := SIF_RANGE;
  end;
  GetScrollInfo(Sender.Handle, SB_VERT, Inf);
  if (Inf.nMax &gt; Sender.Height) then
    D := GetSystemMetrics(SM_CXHTHUMB)
  else
    D := 0;
  if Node &lt;&gt; nil then
  begin
    NRect := Sender.GetDisplayRect(Node, -1, False);
    if ((Pt.X &gt; Sender.Width - 71 - D) and (Pt.X &lt; Sender.Width - 16 - D) and
      (Pt.Y &gt; NRect.Bottom - 42) and
      (Pt.Y &lt; NRect.Bottom - 29))
      or
      ((Pt.X &gt; Sender.Width - 71 - D) and (Pt.X &lt; Sender.Width - 35 - D) and
      (Pt.Y &gt; NRect.Bottom - 29) and
      (Pt.Y &lt; NRect.Bottom - 16))
    then
      Cursor := crHandPoint
    else
      Cursor := crDefault;
  end;
end;
//---------------------------------------------------------------------------
procedure TfrmMain.VTGetHintSize(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; var R: TRect);
begin
  with R do
  begin
    Left := 0;
    Top := 0;
    Right := 250;
    Bottom := 80;
  end;
end;
//---------------------------------------------------------------------------
// Получение ширины узла. Если Вы включили опцию toFullRowSelect, то
// в контексте данного примера это событие необязательно.
//---------------------------------------------------------------------------
procedure TfrmMain.VTGetNodeWidth(Sender: TBaseVirtualTree; HintCanvas: TCanvas;
  Node: PVirtualNode; Column: TColumnIndex; var NodeWidth: Integer);
var
  D: Integer;
  Inf: tagScrollInfo;
begin
  // Смотрим, виден ли вертикальный скрол.
  // Если есть, то его ширину нужно будет вычесть из ширины узла
  with Inf do
  begin
    cbSize := SizeOf(tagScrollInfo);
    fMask := SIF_RANGE;
  end;
  GetScrollInfo(Sender.Handle, SB_VERT, Inf);
  if (Inf.nMax &gt; Sender.Height) then
    D := GetSystemMetrics(SM_CXHTHUMB)
  else
    D := 0;
  // Вычитаем из ширины дерева ширину вертикального скрола, отступа и края
  // дерева
  NodeWidth := Sender.Width - D - VT.Indent - VT.Margin;
end;
</pre><br>
Реализация потока, имитирующего процесс доставки, будет выглядеть так (комментарии даны по ходу листинга):<br>
<br>
<pre class="brush: pascal">	
// Поток, имитирующий выполнение какой-то операции
TProcessThread = class(TThread)
private
  FWnd: HWND; // Хендл формы. Необходим для отсылки сообщений ему
  FNode: PVirtualNode; // Узел, за который поток отвечает
  FValue: Byte; // Процесс доставки
  procedure RepaintTree;
  procedure CheckDeleted;
public
  constructor Create(Suspended: Boolean; var InitialValue: Byte;
    CallingForm: HWND; VTNode: PVirtualNode);
protected
  procedure Execute; override;
end;
constructor TProcessThread.Create(Suspended: Boolean;
  var InitialValue: Byte; CallingForm: HWND; VTNode: PVirtualNode);
begin
  inherited Create(Suspended);
  FWnd := CallingForm;
  FNode := VTNode;
  FValue := InitialValue;
  FreeOnTerminate := True;
end;
//---------------------------------------------------------------------------
// Отсылаем сообщение форме о том, что узлу FNode необходима перерисовка
// Параметры:
//   WParam - адрес узла
//   LParam - текущее значение процесса доставки
//---------------------------------------------------------------------------
procedure TProcessThread.RepaintTree;
begin
  SendMessage(FWnd, VT_REPAINTTREE, Integer(FNode), FValue);
end;
//---------------------------------------------------------------------------
// Проверить, не был ли удалён узел, за который мы отвечает. Если был, то
// делать нам больше нечего.
//---------------------------------------------------------------------------
procedure TProcessThread.CheckDeleted;
begin
  if not Assigned(FNode) then
    Terminate;
end;
//---------------------------------------------------------------------------
procedure TProcessThread.Execute;
begin
  while FValue &lt; 100 do
  begin
    Sleep(100);
    Synchronize(CheckDeleted);
    Inc(FValue);
    Synchronize(RepaintTree);
  end;
end;
</pre>Обработка сообщения VT_REPAINTTREE у формы:  <br>
<pre class="brush: pascal">	
const
  // Сообщение для уведомления дерева потоком о том, что необходимо
  // перерисовать указанный узел
  VT_REPAINTTREE = WM_USER + 500;
procedure TfrmMain.VTREPAINTTREE(var Message: TMessage);
var
  Node: PVirtualNode;
  ItemNode: PItemNode;
begin
  Node := Pointer(Message.WParam);
  if Assigned(Node) then
  begin
    ItemNode := VT.GetNodeData(Node);
    ItemNode^.Process := Message.LParam;
    VT.RepaintNode(Node);
  end;
end;
</pre><br>
Для правильной работы примера необходимо настроить дерево. Чтобы включить подсказку, необходимо изменить свойство&nbsp;<b>HintMode</b>&nbsp;на&nbsp;<b>hmHint</b>&nbsp;(это свойство будет подробнее рассмотрено позже).<br>
<br>
Теоритически,  наше задание можно было бы выполнить и с помощью обычного  TVirtualStringTree, но он ориентирован только на отображение текстовых  данных и неизвестно какие проблемы и опасности могут поджидать Вас при  работе с ним. Просто запомните, если Вам требуется существенное  изменение отображения данных, то используйте TVirtualDrawTree, в  противном случае достаточно TVirtualStringTree.<br>
<br>
<i>Полная  версия проекта Figure 1.5, демонстрирующего изменённую отрисовку дерева  с использованием TVirtualDrawTree, находится в папке Fig 1.5. В нём  также присутствуют дополнительные комментарии к коду.</i><br>
<br>
<b>Добавлено @ 00:37</b><br>
<b>6.0. Сохранение и загрузка VT из файла.</b><br>
Какой  толк от данных, если результат вычислений нигде не хранить? Давайте  посмотрим что есть в VT для обеспечения сохранения и загрузки его  содержимого и какими способами это можно сделать. Мы возьмем максимально  простой пример: текстовое дерево из двух колонок с возможной  вложенностью узлов. Такая картина наиболее часто встречается в  повседневной жизни.<br>
<br>
<b>6.1. Хранение дерева стандартными средствами.</b><br>
VT  реализует такие методы, как LoadFromFile и SaveToFile, предназначенные  для загрузки и сохранения дерева в файл. Основа их действия – методы  LoadFromStream и SaveToStream, предназначенные для работы с потоком.  Давайте попробуем вызвать их и проанализировать полученный файл.<br>
Данные для узла: </div><pre class="brush: pascal">	
type
  PNodeData = ^TNodeData;
  TNodeData = record
    Caption: WideString;
    Value: Integer;
  end;
</pre><br>
Заполняем дерево случайными данными:<br>
<br>
<pre class="brush: pascal">	
const
  Strs: array[0..4] of WideString = (
    'Εκλογές στο Ισραήλ',
    'Απεβίωσε ο Γιάννης Ξενάκης',
    'Μεταμόσχευση χεριού',
    'Σάμπα, κλόουν, μασκαράδες και πενιές',
    'Δοκιμάζει τις αντοχές του'
  );
  Ints: array[0..4] of Integer = (
    938,
    5346,
    23,
    789,
    2888
  );
procedure TfrmMain.BtnFillClick(Sender: TObject);
var
  i, j: Integer;
  NewNode1, NewNode2: PVirtualNode;
  ItemData: PNodeData;
begin
  Randomize;
  for i := 0 to 1 do
  begin
    NewNode1 := VT.AddChild(nil);
    ItemData := VT.GetNodeData(NewNode1);
    with ItemData^ do
    begin
      Caption := Strs[Random(4)];
      Value := Ints[Random(4)];
    end;
    for j := 0 to 9 do
    begin
      NewNode2 := VT.AddChild(NewNode1);
      ItemData := VT.GetNodeData(NewNode2);
      with ItemData^ do
      begin
        Caption := Strs[Random(4)];
        Value := Ints[Random(4)];
      end;
    end;
  end;
end;
</pre><br>
Попробуем без лишних телодвижений просто вызвать оба метода и посмотреть на результат:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.BtnLoadClick(Sender: TObject);
begin
  VT.LoadFromFile('vt.dat');
end;
procedure TfrmMain.BtnSaveClick(Sender: TObject);
begin
  VT.SaveToFile('vt.dat');
end;
</pre><br>
Добавьте обработчик OnGetText дереву для отображения текста и скомпилируйте пример. Нажмите на кнопку, которой назначен обработчик BtnFillClick, чтобы заполнить дерево. Затем жмите на кнопку сохранения. В папке с примером появится файл vt.dat, откроем его блокнотом или любым hex редактором. Что мы видим? Бинарный файл, в котором проскакивает текстовая информация, очевидно взятая из поля Caption нашей структуры. Хорошо, очистите дерево и попробуйте загрузить его, нажав на кнопку загрузки. Структура дерева восстановится, но все его узлы будут пусты… Зачем же тогда в полученном файле присутствует содержимое узлов? Дерево сохраняет содержимое узлов, но при этом никак не загружает его. Получается, что это мусор в файле? И да и нет. Такое поведение дерева объясняется тем, что текст узлов (но не данные узла) помещается в поток TStream при операциях с буфером обмена и drag&amp;drop. Затем он читается из потока для восстановления узла. Но нужно это только для передачи текста узлов сторонним приложениям и контроллам, например TRichEdit или MSWord (они же ничего про данные узла знать не могут), а в нашем случае мы работаем с файлом, поэтому эта информация будет проигнорирована деревом, как информация, не предназначенная для загрузки из файла.<br>
Но что тогда отвечает за процесс загрузки и сохранения? Как избавиться от этого «мусора» в файле? Для начала, запретим дереву помещать эту информацию в поток. За это отвечает опция toSaveCaptons из StringOptions раздела настроек дерева, которую необходимо в нашем случае поставить в False. Теперь необходимо самостоятельно реализовать запись содержимого узла в поток. Для этого нам в помощь присутствуют два простых события:<br>
<br>
OnLoadNode – вызывается при чтении данных для каждого узла.<br>
OnSaveNode – вызывается при сохранении данных для каждого узла.<br>
<br>
<br>
Таким образом, наша задача заключается только в заполнении содержимого потока по мере записи в него структуры дерева. О записи структуры дерева VT заботится самостоятельно.<br>
<br>
Добавим обработчики обоим событиям:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.VTLoadNode(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Stream: TStream);
var
  Reader: TReader;
  NodeData: PNodeData;
begin
  Reader := TReader.Create(Stream, 8096);
  try
    NodeData := Sender.GetNodeData(Node);
    with NodeData^, Reader do
    begin
      Caption := ReadWideString;
      Value := ReadInteger;
    end;
  finally
    FreeAndNil(Reader);
  end;
end;
procedure TfrmMain.VTSaveNode(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Stream: TStream);
var
  Writer: TWriter;
  NodeData: PNodeData;
begin
  Writer := TWriter.Create(Stream, 8096);
  try
    NodeData := Sender.GetNodeData(Node);
    with Writer, NodeData^ do
    begin
      WriteWideString(Caption);
      WriteInteger(Value);
    end;
  finally
    FreeAndNil(Writer);
  end;
end;
</pre><br>
Тем,  кто работал с массивами и реализовывал их методы загрузки и сохранения,  этот код покажется довольно знакомым. Мы используем классы TReader и  TWriter для работы с потоком. В нашем случае мы помещаем в поток строку и  число от каждого узла. При загрузке они также легко извлекаются из  потока. Снова скомпилируйте пример и повторите предыдущие действия по  сохранению дерева в файл. На этот раз мы увидим иную картину. В файле  уже не будет прежнего мусора, а строки будут сохранены в Юникоде и  завершены null-terminating (#0) символом. По соседству с ними будут  располагаться числа. Вернёмся в приложение. Очистите дерево и нажмите на  кнопку загрузки. Вуаля! Дерево восстановлено в своём первозданном виде.  Таким образом, Вы можете хранить любые типы данных (кроме referenced  естественно) в бинарном файле и легко их загружать.<br>
<br>
<b>6.2. Хранение дерева в XML файле.</b><br>
Но  что если Вас не устраивает перспектива хранения дерева в бинарном  файле? Что если у Вас есть собственный формат данных, который Вы хотите  использовать? В этом случае все действия по загрузке и сохранения можно  полностью выполнить самому. Вот простой пример как можно то же самое  дерево из предыдущего примера хранить в XML файле. Для работы с XML Я  использовал стандартный парсёр от Microsoft (TXMLDocument). Тем не  менее, Вам ничто не мешает переписать пример под Ваш любимый парсёр.<br>
<br>
Зарузка: </div><pre class="brush: pascal">	
procedure TfrmMain.BtnLoadXMLClick(Sender: TObject);
var
  XMLDocument: TXMLDocument;
  procedure LoadXML(const ANodeList: IXMLNodeList; AParent: PVirtualNode);
  var
    i: Integer;
    NewNode: PVirtualNode;
    NodeData: PNodeData;
  begin
    for i := 0 to ANodeList.Count - 1 do
    begin
      NewNode := VT.AddChild(AParent);
      NodeData := VT.GetNodeData(NewNode);
      with NodeData^ do
      begin
        Caption := VarToWideStr(ANodeList[i].Attributes['Caption']);
        Value := StrToIntDef(
                VarToStr(
                ANodeList[i].Attributes['Value']
                ), 0);
      end;
      LoadXML(ANodeList[i].ChildNodes, NewNode);
    end;
  end;
begin
  if not FileExists('vt.xml') then
  begin
    MessageBox(Handle, 'Файл vt.xml не найден.', PChar(Application.Title),
      MB_ICONINFORMATION + MB_OK);
    Exit;
  end;
  XMLDocument := TXMLDocument.Create(Self);
  try
    XMLDocument.LoadFromFile('vt.xml');
    // Для каждой ветки XML дерева создать узел в дереве и зарузить поля
    // для структуры данных из аттрибутов
    // Не забываем использовать блоки Begin/End Update.
    VT.BeginUpdate;
    try
      LoadXML(XMLDocument.DocumentElement.ChildNodes, nil);
    finally
      VT.EndUpdate;
    end;
  finally
    FreeAndNil(XMLDocument);
  end;
end;
</pre><br>
Сохранение:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.BtnSaveXMLClick(Sender: TObject);
var
  XMLDocument: TXMLDocument;
  procedure SaveXML(ANode: PVirtualNode; const AParent: IXMLNode);
  var
    i: Integer;
    NewNode: IXMLNode;
    NextNode: PVirtualNode;
    NodeData: PNodeData;
  begin
    NextNode := ANode.FirstChild;
    if Assigned(NextNode) then
      repeat
        NodeData := VT.GetNodeData(NextNode);
        NewNode := AParent.AddChild('Node');
        with NewNode, NodeData^ do
        begin
          Attributes['Caption'] := Caption;
          Attributes['Value'] := Value;
        end;
        SaveXML(NextNode, NewNode);
        NextNode := NextNode.NextSibling;
      until
        NextNode = nil;
  end;
begin
  XMLDocument := TXMLDocument.Create(Self);
  try
    with XMLDocument do
    begin
      Active := True;
      Encoding := 'UTF-16';
      AddChild('VirtualTreeview');
      Options := Options + [doNodeAutoIndent];
    end;
    SaveXML(VT.RootNode, XMLDocument.DocumentElement);
    XMLDocument.SaveToFile('vt.xml');
  finally
    FreeAndNil(XMLDocument);
  end;
end;
</pre><br>
<b>6.3. Экспорт содержимого дерева в различные форматы.</b><br>
VT  предлагает замечательную возможность экспортировать своё содержимое в  различные форматы данных. На данный момент поддерживается текст, Юникод,  RTF и HTML. Что примечательно, VT экспортирует содержимое в текст,  сохраняя при этом табличную структуру. Вот короткий пример экспорта в  HTML с сохранением в файл. Экспорт для всех остальных форматов проходит  примерно также. </div><pre class="brush: pascal">	
procedure TfrmMain.BtnExportHTMLClick(Sender: TObject);
const
  HTMLHead = ''#13#10 +
    ''#13#10 +
    ''#13#10 +
    '  '#13#10 +
    '  <title>Virtual Treeview HTML</title>'#13#10 +
    ''#13#10 +
    ''#13#10;
  HTMLFoot = ''#13#10 +
    '' + #13#10;
var
  Fs: TFileStream;
  Str: String;
  Data: Pointer;
begin
  Fs := TFileStream.Create('html.html', fmCreate);
  try
    Str := HTMLHead + VT.ContentToHTML(tstAll) + HTMLFoot;
    Data := PChar(Str);
    Fs.WriteBuffer(Data^, Length(Str));
  finally
    FreeAndNil(fs);
  end;
  ShellExecute(Handle, 'open', 'html.html', nil, nil, SW_RESTORE);
end;
</pre><br>
<b>7.0. Обзор типа TVirtualNode.</b><br>
До сих  пор наша работа с VT неизменно была связана с узлами, представленными  типом TVirtualNode, но мы не уделяли ему особого внимания. А ведь он  содержит много полезных и интересных свойств, например, позволяет задать  тип отметки для конкретных узлов и получить доступ ко многим его  свойствам. Восполним этот пробел.<br>
<br>
<b>7.1. Стандартные свойства.</b><br>
Каждый  узел, являясь экземпляром типа TVirtualNode, содержит множетсво  вспомогательных и информативных свойств, которые с успехом можно  использовать ради любых целей.<br>
<ul><li><b>Index</b>&nbsp;– индекс узла в дереве по отношении к своему родителю. Т.е. абсолютным индексом он не является.</li>
<li><b>ChildCount</b>&nbsp;– количество дочерних элементов узла. Вручную не изменяется. Заполняется в обработчике события&nbsp;<b>OnInitChildren</b>.</li>
<li><b>NodeHeight</b>&nbsp;–  высота узла. VT позволяет узлам иметь различные размеры, применение  этой возможности будет подробнее рассмотрено ниже. Фактически, это read  only поле, т.к. его изменение, кроме как к глюкам отрисовки, ни к чему  не приводит. Корректное изменение этого свойства возможно только в  событии OnMeasureItem. Если планируете испоьзование этого поля, то  желательно включить TreeOptions.MiscOptions.toVariableNodeHeight опцию  дерева.</li>
<li><b>States</b>&nbsp;– набор настроек узла.<ul><li><b>vsInitialized</b>&nbsp;– True, если данный узел прошёл событие OnInitNode.</li>
<li><b>vsChecking</b>&nbsp;– True, если пользователь зажал отметку и ещё не отпустил кнопку мыши.</li>
<li><b>vsCutOrCopy</b>&nbsp;– узел был определён для копирования или вставки.</li>
<li><b>vsDisabled</b>&nbsp;– узел выключен и не отвечает на действия пользователя.</li>
<li><b>vsDeleting</b>&nbsp;– устанавливается деревом в True сразу перед тем, как узел должен быть удалён.</li>
<li><b>vsExpanded</b>&nbsp;– True, если узел раскрыт.</li>
<li><b>vsHasChildren</b>&nbsp;– позволяет указать наличие дочерних узлов. При этом узел не обязательно должен их иметь.</li>
<li><b>vsVisible</b>&nbsp;– True, если узел видно в дереве.</li>
<li><b>vsSelected</b>&nbsp;– True, если узел выделен.</li>
<li><b>vsAllChildrenHidden</b>&nbsp;–  True, если у узла включено свойство vsHasChildren, но все его дочерние  элементы спрятяны (имеют свойство vsVisible в True).</li>
<li><b>vsClearing</b>&nbsp;– True, если дочерние узлы начали удаляться.</li>
<li><b>vsMultiline</b>&nbsp;– True, если текст узла должен быть перенесён, чтобы совпасть с шириной колонки.</li>
<li><b>vsHeightMeasured</b>&nbsp;– True, если высота узла была опеределена в обработчике события OnMeasureItem.</li>
<li><b>vsToggling</b>&nbsp;– используется деревом для предотвращения зацикливания при сворачивании/разворачивания узла.</li>
</ul></li>
<li><b>Align</b>&nbsp;–  смещение узла в диапазоне от 0 до 255. Чем больше значение, тем ниже  будут распологаться кнопка сворачивания/разворачивания и отметка. Данное  поле тем не менее не влияет на положение текста в узле. Часто  использутеся вместе со свойством дерева NodeAlignment, которое будет  рассмотрено ниже. Возможно установить только в событии инициализации.</li>
<li><b>CheckState</b>&nbsp;– содержит текущее состояние отметки.<ul><li><b>csUncheckedNormal</b>&nbsp;– узел не отмечен и не зажат.</li>
<li><b>csUncheckedPressed</b>&nbsp;– узел не отмечен, но пользователь зажал кнопку мыши над отметкой.</li>
<li><b>csCheckedNormal</b>&nbsp;– узел отмечен.</li>
<li><b>csCheckedPressed</b>&nbsp;– узел зажат, но пользователь зажал кнопку мыши над отметкой.</li>
<li><b>csMixedNormal</b>&nbsp;–  толко для отметок типа TCheckBox в узлах со свойством  ctTriStateCheckBox. Обозначает, что отметка имеет промежуточное  состояние (аналог Grayed в TCheckBox).</li>
<li><b>csMixedPressed</b>&nbsp;– то же самое, но отметка зажата левой кнопкой мыши.</li>
</ul></li>
<li><b>CheckType</b>&nbsp;– тип отметки. Возможно установить только в событии инициализации.<ul><li><b>ctNone</b>&nbsp;– узел без отметки.</li>
<li><b>ctTriStateCheckBox</b>&nbsp;– узел с отметкой типа TCheckBox, которая может иметь 3 состояния (отмечена, grayed, не отмечена).</li>
<li><b>ctCheckBox</b>&nbsp;– узел с отметкой типа TCheckBox, которая может иметь 2 состояния.</li>
<li><b>ctRadioButton</b>&nbsp;– узел с отметкой типа TRadioButton.</li>
<li><b>ctButton</b>&nbsp;– узел с кнопкой слева от надписи.</li>
</ul></li>
<li><b>Dummy</b>&nbsp;– зарезервировано. Необходимо для выравнивания размера структуры узла до четырёх байтов (DWORD).</li>
<li><b>TotalCount</b>&nbsp;– сумма узла и всех его дочерних узлов и их дочерних узлов и т.д.</li>
<li><b>TotalHeight</b>&nbsp;– общая высота, занимаемая на экране данным узлом и всеми его дочерними узлами.</li>
<li><b>Parent</b>&nbsp;– указатель на узел родителя для данного узла.</li>
<li><b>PrevSibling</b>&nbsp;– указатель на предыдущий узел связанного списка. Если данный узел является первым в списке, то поле равно nil.</li>
<li><b>NextSibling</b>&nbsp;– то же самое, но указывает на следующий узел в списке.</li>
<li><b>FirstChild</b>&nbsp;– указатель на самый первый дочерний узел.</li>
<li><b>LastChild</b>&nbsp;– указатель на самый последний дочерний узел.</li>
</ul><b>7.2. Отметки для узла.</b><br>
Как  Вы могли уже видеть выше, в отличие от TListView и TTreeView у VT есть  аж четыре (!) вида отметки. Давайте подробнее рассмотрим каждый.<br>
<b>ctCheckBox</b>&nbsp;–  отметка типа TCheckBox, знакомая Вам по TListView и TTreeView. Один раз  нажал – повесил галочку, другой раз нажал – снял галочку.<br>
<b>ctRadioButton</b>&nbsp;– отметка типа TRadioButton. В списке узлов одновременно может быть отмечен только один узел.<br>
<b>ctTriStateCheckBox</b>&nbsp;–  это отметка наподобие TCheckBox, но включающая в себя также третье  состояние (grayed), изображённое в виде квадрата, а не галки. Такой вид  отметок часто можно встретить в приложениях, предлагающих выбрать  какой-то набор компонетов для установки. В них отметка принимает  grayed-вид, если выбрана только часть компонент из предложеннных для  установки.<br>
<b>ctButton</b>&nbsp;– немного необычный вид отметки.  Очень удобно использовать для показа popup меню для индивидуального  узла. Смотрится довольно оригинально и профессионально.<br>
Учтите, что отметки будут видны только в главной колонке дерева, т.е. в той, что имеет индекс MainColumn.<br>
Идеальное место для включения отметок – событие&nbsp;<b>OnInitNode</b>: </div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTInitChildren(Sender: TBaseVirtualTree; Node: PVirtualNode;
  var ChildCount: Cardinal);
begin
  if Sender.GetNodeLevel(Node) &lt; 5 then
    ChildCount := 6
  else
    ChildCount := 0;
end;
procedure TfrmMain.VTInitNode(Sender: TBaseVirtualTree; ParentNode,
  Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates);
var
  Lvl: Integer;
begin
  Lvl := Sender.GetNodeLevel(Node);
  if Lvl &lt; 5 then
  begin
    InitialStates := InitialStates + [ivsHasChildren];
    case Lvl of
      0: Node.CheckType := ctButton;
      1: Node.CheckType := ctRadioButton;
      2: Node.CheckType := ctTriStateCheckBox;
      3: Node.CheckType := ctTriStateCheckBox;
      4: Node.CheckType := ctCheckBox;
      5: Node.CheckType := ctNone;
    end;
  end;
end;
</pre><br>
В  этом примере дерево будет заполняться шестью узлами для каждого  родительского узла пока их уровень вложенности не достигнет шести. Тип  отметки выбирается в соответствии с уровнем вложенности узла.<br>
С отметками связаны события:<br>
<ul><li><b>OnChecking</b>&nbsp;– происходит после нажатия на отметку и перед тем, как отпускается кнопка мыши.</li>
<li><b>OnChecked</b>&nbsp;– происходит сразу после того, как была отпущена кнопка мыши.</li>
</ul>VT  также позволяет указать изображения, которые будут использоваться для  отметок. Кроме того, Вы можете нарисовать собственную картинку для  каждого типа отметки и её состояний. VT уже имеет несколько готовых  вариантов картинок для отметок, Вы можете просмотреть их в  свойстве&nbsp;<b>CheckImageKind</b>. Чтобы использовать собственные  изображения, поместите их в TImageList и присоедините к дереву через  свойство CustomCheckImages. Переключите свойство CheckImageKind в  ckCustom и отметки примут вид Ваших картинок. В папке Fig 1.7\res  находится файл-пример, содержащий изменённые изображения отметок. Вы  можете использовать его как шаблон для создания собственных изображений.<br>
<br>
<b>7.3. Опция toAutoTriStateTracking.</b><br>
Если  Вы уже скомпилировали пример и проверили его работу, то наверняка  заметили, что у узлов с отметкой типа ctTriStateCheckBox состояние  устанавливается автоматически в соответствии с состоянием отметки  дочерних узлов. Если ни один из дочерних узлов не отмечен, то и данный  узел не отмечен. Если все дочерние узлы отмечены, то и данный узел  отмечен. Если только часть дочерних узлов отмечена, то данный узел будет  иметь состояние отметки grayed (csMixedNormal). Надо отдать должное  разработчику компонента за такую удобную возможность. Впрочем, если Вы  не хотите избежать такого поведения дерева, то просто отключите  опцию&nbsp;<b>toAutoTriStateTracking</b>, обитающую в TreeOptions.AutoOptions. Именно она отвечает за всё это.<br>
<br>
Чтобы  лучше закрепить знания о TVirtualNode типе, ознакомьтесь с примером  Figure 1.7. В нём очень хорошо видна работа каждого свойства типа.<br>
<br>
<i>Проект Figure 1.7, демонстрирующий работу с типом TVirtualNode находится в папке Fig 1.7.</i><br>
<br>
<b>Добавлено @ 00:38</b><br>
<b>8.0. Небольшие примеры кода. Описание различных свойств VT, не попадающих под категории, рассмотренные выше.</b><br>
Я  специально решил выделить такие моменты в отдельную главу, чтобы не  устраивать кашу среди предыдущих примеров и в то же время акцентировать  внимание и на них. В конце статьи Я также полностью рассмотрю назначение  всех опций VT.<br>
8.1. Цветовые настройки.<br>
VT выделяет все настраиваемые цвета (кроме&nbsp;<b>Color</b>)  в отдельный небольшой класс – TVTColors, наследованный от TPersistent,  что говорит о том, что Вы сможете легко обменивать цветовые настройки  между деревьями простым методом Assign. Все цвета VT доступны для  изменения в поле Colors.<br>
<ul><li><b>BorderColor</b>&nbsp;– цвет дополнительной границы, устанавливаемой в свойстве BorderWidth.</li>
<li><b>DisabledColor</b>&nbsp;– цвет текста отключённого (vsDisabled) узла.</li>
<li><b>DropMarkColor</b>&nbsp;– цвет небольшой отметки, появляющейся при Drag&amp;Drop переносе узла по верху или по низу другого.</li>
<li><b>DropTargetBorder</b>&nbsp;– цвет границы прямоугольника, закрашивающего узел, в который производится Drag&amp;Drop вставка (DropTargetNode).</li>
<li><b>DragTargetColor</b>&nbsp;– цвет самого прямоугольника, закрашивающего узел, в который производится Drag&amp;Drop вставка (DropTargetNode).</li>
<li><b>FocusedSelectionBorderColor</b>&nbsp;– цвет границы выделенного узла.</li>
<li><b>FocusedSelectionColor</b>&nbsp;– цвет выделенного узла.</li>
<li><b>GridLineColor</b>&nbsp;– цвет линий сетки у дерева.</li>
<li><b>HeaderHotColor</b>&nbsp;– цвет текста заголовка колонки, над которой сейчас находится курсор.</li>
<li><b>HotColor</b>&nbsp;– цвет узла, над которым находится курсор.</li>
<li><b>SelectionRectangleBlendColor</b>&nbsp;– цвет фона, заполняющего прямоугольник выделения.</li>
<li><b>SelectionRectangleBorderColor</b>&nbsp;– цвет границы прямоугольника выделения.</li>
<li><b>TreeLineColor</b>&nbsp;– цвет соединительных линий узлов.</li>
<li><b>UnfocusedSelectionBorderColor</b>&nbsp;– цвет границы выделенного, но не имеющего фокус узла.</li>
<li><b>UnfocusedSelectionColor</b>&nbsp;– цвет выделенного, но не имеющего фокус узла.</li>
</ul>Особенно  интересны пары параметров, где один отвечает за границу, а другой за  фон. Комбинируя различные цвета между ними, можно получать довольно  интересные сочетания.<br>
<br>
<b>8.2. Отображение подсказки.</b><br>
VT позволяет выводить подсказку тремя различными вариантами. Режим подсказки задаётся в параметре HintMode:<br>
<ul><li><b>hmDefault</b>&nbsp;– передаёт вывод подсказки стандартным обработчикам VCL. В этом случае в подсказке будет выведен текст из поля&nbsp;<b>Hint</b>.</li>
<li><b>hmHint</b>&nbsp;– использует для получения текста подсказки событие&nbsp;<b>OnGetHint</b>. Предусмотрен для вывода индивидуальной подсказки для каждого узла.</li>
<li><b>hmHintAndDefault</b>&nbsp;–  комбинация двух предыдущих параметров. Если курсор будет находится над  узлом, то действие будет эквивалентно действию параметру hmHint, если же  курсор будет находится непосредственно над пустой областью дерева, то  действие будет эквивалентно параметру hmDefault.</li>
<li><b>hmTooltip</b>&nbsp;–  особый параметр. Применяется, если Вы хотите отобразить текстовую  подсказку над узлами, текст которых не умещается в колонке и обрезается.  В этом случае обработка события OnGetHint не нужна, VT сам всё сделает  за Вас. Учтите, что если Вы всё же обработаете это событие, то своим  действием оно перекроет этот параметр.</li>
</ul>Наиболее часто  используемый параметр – hmTooltip. Он не обязует Вас лишними  обработчиками и в то же время облегчает навигацию по дереву с узлами с  длинным текстом. Если же Вы хотите выводить собственный текст в  подсказке, то можете воспользоваться параметром hmHint. В этом случае  обработчик получения подсказки будет примерно такой: </div><pre class="brush: pascal">	
procedure TfrmMain.VTGetHint(Sender: TBaseVirtualTree; Node: PVirtualNode;
  Column: TColumnIndex; var LineBreakStyle: TVTTooltipLineBreakStyle;
  var HintText: WideString);
begin
  if VT.HintMode &lt;&gt; hmTooltip then
    HintText := 'Хинт из OnGetHint события: текст подсказки...'
  else
    HintText := VT.Text[Node, Column];
end;
</pre><br>
Параметр  hmDefault не требует никаких обработчиков. Это индивидуальная подсказка  дерева из его поля Hint, как и у любых других VCL классов.<br>
<br>
VT позволяет использовать анимацию для всплывающей подсказки. Её можно настроить параметром&nbsp;<b>HintAnimation</b>&nbsp;дерева.<br>
<ul><li><b>hatNone</b>&nbsp;– выключить анимацию подсказки.</li>
<li><b>hatFade</b>&nbsp;– эффект затухания, плавное появление подсказки.</li>
<li><b>hatSlide</b>&nbsp;– скользящий эффект появления подсказки.</li>
<li><b>hatSystemDefault</b>&nbsp;– используется эффект анимации, установленный в системе. Рекомендуемый параметр.</li>
</ul><b>8.3. Отображение выделения.</b><br>
Цвет  выделения задаётся в полях параметра Colors, который уже был рассмотрен  выше. Кроме этих параметров, VT позволяет указать прозрачность для  выделенных узлов. Это означает, что через выделенные узлы будет  просвечиваться фон дерева. Степень прозрачности задаётся в поле  SelectionBlendFactor. Сама эта возможность по умолчанию отключена в  настройках дерева. Включить её можно, изменив опцию  TreeOptions.PaintOptions.toUseBlendedSelection в True.<br>
Помимо этого,  VT позволяет изменить форму выделения. Стандартный прямоугольник  выделения можно закруглить с помощью поля SelectionCurveRadius.<br>
<br>
<i><b>Обратите внимание</b>:  VT на данный момент не поддерживает закругление выделения при  включённых настройках прозрачности выделения. Т.е. действие поля  SelectionCurveRadius опускается при включённой опции  toUseBlendedSelection.</i><br>
<br>
<br>
Прямоугольник выделения (тот, что растягивается мышью) тоже может менять своё отображение. С помощью параметра&nbsp;<b>DrawSelectionMode</b>&nbsp;Вы можете изменить его стиль.&nbsp;<b>smDottedRectangle</b>&nbsp;для прямоугольника с границами в виде точек и отсутствием заливки (используется стандартными TTreeView и TListView),&nbsp;<b>smBlendedRectangle</b>&nbsp;для  прямоугольника выделения в стиле Windows XP (прозрачный синий  прямоугольник по умолчанию). Свойство активно только при выключенных  темах оформления. Это означает, что если дерево поддерживает визуальные  стили, то значение параметра всегда будет smBlendedRectangle.<br>
<br>
<b>8.4. Параметры анимации.</b><br>
Несколько параметров анимации и прокрутки.<br>
<ul><li><b>AnimationDuration</b>&nbsp;– длительность анимации при раскрытии/скрытии узла. Анимация включается опцией TreeOptions.AnimationOptions.<b>toAnimatedToggle</b>&nbsp;дерева.</li>
<li><b>AutoExpandDelay</b>&nbsp;– длительность паузы перед автоматическом раскрытии узла. Включается опцией TreeOptions.AutoOptions.<b>toAutoExpand</b>&nbsp;дерева.</li>
<li><b>AutoScrollDelay</b>&nbsp;– длительность паузы перед автоматической прокруткой дерева. Включается опцией TreeOptions.AutoOptions.<b>toAutoScroll</b>&nbsp;дерева.</li>
<li><b>AutoScrollInterval</b>&nbsp;– количество узлов, прокручиваемое при перемещении колёсика мыши.</li>
</ul><b>8.5. Параметры отображения линий сетки и соединительных линий узлов.</b><br>
Даже  для такой мелочи как соединительные линии и линии сетки предусмотрены  свои настройки. Цвет, как Вы уже знаете, изменяется параметрами  GridLineColor и TreeLineColor. Параметры, рассмотренные здесь, позволяют  управлять стилем отрисовки этих самих линий.<br>
Для линий, соединяющих узлы, имеется параметр интересный&nbsp;<b>LineMode</b>. Он интересен тем, что помимо обычного стиля отрисовки&nbsp;<b>lmNormal</b>&nbsp;(а-ля TTreeView/TListView) позволяет указать стиль&nbsp;<b>lmBands</b>.  Тогда соединительные линии узлов будут образовывать ряды и колонки,  похожие на таблицу или диаграмму. Смотрится довольно необычно по  сравнению с обычным стилем.<br>
Для линий сетки существует параметр&nbsp;<b>LineStyle</b>:<br>
<ul><li><b>lsCustomStyle</b>&nbsp;– определяет, что Вы сами будете задавать стиль линий сетки через событие OnGetLineStyle.</li>
<li><b>lsDotted</b>&nbsp;– линии сетки в виде пунктира.</li>
<li><b>lsSolid</b>&nbsp;– стиль, используемый TTreeView/TListView (обычные сплошные линии).</li>
</ul>Если  вам не хватает стилей lsDotted и lsSolid, то Вы вольны указать свой  собственный стиль в обработчике события OnGetLineStyle. Его параметру  Bits необходимо передать битмап 6*6 пикселей, представленный указателем  на массив байт (TByteArray). Вот простой пример, увеличивающий  расстояние между пунктирами на максимальное: </div><pre class="brush: pascal">	
procedure TfrmMain.VTGetLineStyle(Sender: TBaseVirtualTree; var Bits: Pointer);
var
  i: Integer;
begin
  Bits := @Arr;
  for i := 0 to Length(Arr) - 1 do
    Arr[i] := 254;
end;
</pre><br>
<b>8.6. Отображение узла.</b><br>
Нами остались нерассмотренными ещё несколько свойств, влияющих на положение узла в ячейке.<br>
<b>NodeAlignment</b>&nbsp;позволяет  указать относительно чего будет смещаться узел. Смещение, как Вы  помните, задаётся в поле Align TVirtualNode записи.<br>
<ul><li><b>naFromBottom</b>&nbsp;– смещение относительно нижнего края ячейки.</li>
<li><b>naFromTop</b>&nbsp;– смещение относительного верхнего края.</li>
<li><b>naProportional</b>&nbsp;–  пропорциональное смещение, не направленное ни в ту, ни в другую  сторону. В этом случае на положение узла будет влиять только значение  поля Align.</li>
</ul>Параметр&nbsp;<b>ButtonStyle</b>&nbsp;позволяет изменить стиль кнопки развёртывания/свёртывания узла. У него может быть всего два значения:<br>
<br>
<ul><li><b>bsRectangle</b>&nbsp;– кнопка в виде прямоугольника с плюсом/минусом.</li>
<li><b>bsTriangle</b>&nbsp;– кнопка в виде небольшого чёрного треугольника. Похожий имеют списки и деревья браузера Opera.</li>
</ul>Параметр активен только при отключённых стилях оформления.<br>
&nbsp;<br>
И, наконец, последний параметр –&nbsp;<b>Indent</b>.  Он позволяет указать длину отступа для каждого уровня вложенности  узлов. Чем больше значение этого параметра, тем дальше друг от друга  будут расположены дочерние и родительские узлы.<br>
<br>
<b>8.7. Изменение отрисовки заголовков.</b><br>
Во  всех наших примерах отрисовки мы не изменили отображение одного очень  важного элемента дерева – его заголовка. Думаю, об этом стоит сказать  пару слов.<br>
За отрисовку заголовков отвечают три события:&nbsp;<b>OnAdvancedHeaderDraw</b>,&nbsp;<b>OnHeaderDrawQueryElements</b>&nbsp;и&nbsp;<b>OnHeaderDraw</b>.  В рамках данной статьи Я рассмотрел первые два, так как они более  сложны в исполнении, нежели последнее. С ним уж как-нибудь сами  справитесь .<br>
VT  реализует очень удобный механизм отрисовки заголовков, позволяя какие-то  отдельные элементы рисовать пользователю, а какие-то оставлять на  попечение VT. Например, Вы можете изменить отрисовку фона заголовка  колонки, но при этом оставить неизменным её текст. Или же вообще  изменить отрисовку только какого-то одного заголовка, оставив остальные в  стандартном виде. Что примечательно, изменённая отрисовка доступна как  при включённых стилях оформления, так и при выключенных.<br>
Событие  OnHeaderDrawQueryElements как раз предназначено для того, чтобы передать  дереву список изменяемых вами элементов заголовка.<br>
<ul><li><b>hpeBackground</b>&nbsp;– фон заголовка.</li>
<li><b>hpeDropMark</b>&nbsp;– иконка Drag&amp;Drop перетаскивания.</li>
<li><b>hpeHeaderGlyph</b>&nbsp;– иконка слева от текста заголовка.</li>
<li><b>hpeSortGlyph</b>&nbsp;– иконка сортировки.</li>
<li><b>hpeText</b>&nbsp;– текст заголовка.</li>
</ul>В нашем примере мы заменим фон и текст заголовка, оставив всё остальное без изменений: </div><pre class="brush: pascal">	
//---------------------------------------------------------------------------
// Передаём в набор те элементы, которые мы будем заменять.
// Непереданные элементы (hpeDropMark, hpeHeaderGlyph, hpeSortGlyph)
// останутся на совести дерева.
//---------------------------------------------------------------------------
procedure TfrmMain.VTHeaderDrawQueryElements(Sender: TVTHeader;
  var PaintInfo: THeaderPaintInfo; var Elements: THeaderPaintElements);
begin
  // Мы будем заменять текст колонок и фон всего заголовка
  Elements := [hpeBackground, hpeText];
end;
</pre><br>
А вот так будет выглядеть сама процедура отрисовки:<br>
<br>
<pre class="brush: pascal">	
procedure TfrmMain.VTAdvancedHeaderDraw(Sender: TVTHeader;
  var PaintInfo: THeaderPaintInfo; const Elements: THeaderPaintElements);
begin
  if hpeBackground in Elements then
    with PaintInfo.TargetCanvas do
    begin
      // Рисуем фон всего заголовка дерева
      Brush.Color := $00C9C9C9;
      FillRect(PaintInfo.PaintRectangle);
      // Растягиваем градиент
      StretchDraw(PaintInfo.PaintRectangle, ImgGrad.Graphic);
      if PaintInfo.Column &lt;&gt; nil then
      begin
        // Необходимо нарисовать заголовок какой-то конкретной колонки
        case PaintInfo.Column.Index of
          // Пользователь
          0: Draw(PaintInfo.PaintRectangle.Left + ((PaintInfo.PaintRectangle.Right - PaintInfo.PaintRectangle.Left) div 2) - (ImgUser.Width div 2),
            PaintInfo.PaintRectangle.Top, ImgUser.Graphic);
          // Кол-во сообщений
          1: Draw(PaintInfo.PaintRectangle.Left + ((PaintInfo.PaintRectangle.Right - PaintInfo.PaintRectangle.Left) div 2) - (ImgMsg.Width div 2),
            PaintInfo.PaintRectangle.Top, ImgMsg.Graphic);
        end;
      end;
    end;
end;
</pre><br>
Не забудьте включить изменённую отрисовку опцией заголовка hoOwnerDraw.<br>
<br>
<b>8.8. Многострочные надписи в узлах.</b><br>
VT  позволяет своим узлам иметь многострочные надписи, разрешая это опцией  vsMultiline для узла. В этом случае редактор дерева будет заменён на  многострочный с удобной вертикальной полосой прокрутки.<br>
Кроме своего  явного применения (хранение нескольких строк в одном узле), это свойство  можно использовать как альтернативу обрезающемуся тексту, который не  умещается в границах колонки. Вы можете просто переносить неумещающийся  текст на новые и новые линии. Для включения многострочности принято  использовать событие инициализации узла:</div><br>
<pre class="brush: pascal">	
procedure TfrmMain.VTInitNode(Sender: TBaseVirtualTree; ParentNode,
  Node: PVirtualNode; var InitialStates: TVirtualNodeInitStates);
begin
  // Включаем/выключаем поддержку многострочности
  if CbMultiline.Checked then
    Include(InitialStates, ivsMultiline)
  else begin
    Exclude(InitialStates, ivsMultiline);
    // НЕ ЗАБЫВАЙТЕ ВЫПОЛНЯТЬ ЭТО:
    Node.States := Node.States - [vsMultiline];
    // Это выключит многострочность для узлов, где она раньше была.
  end;
end;
</pre><br>
Но это ещё не всё. Этот код поможет разбить текст на линии, но высоту узлов он не изменит. Т.е. может случиться так, что перенесённые линии текста уже не будут видны. Для корректного подбора высоты с учётом многострочности VT имеет очень полезный метод – ComputeNodeHeight. Он подсчитывает высоту, необходимую для полного отображения узла в ячейке. Применять мы его будет соответственно в обработчике события OnMeasureItem, там, где и указывается высота узлов:</div><pre class="brush: pascal">	
//---------------------------------------------------------------------------
// Подсчёт высоты узлов в соответствии с высотой переносимого текста
//---------------------------------------------------------------------------
procedure TfrmMain.VTMeasureItem(Sender: TBaseVirtualTree;
  TargetCanvas: TCanvas; Node: PVirtualNode; var NodeHeight: Integer);
begin
  if CbMultiline.Checked then
  begin
    NodeHeight := VT.ComputeNodeHeight(TargetCanvas, Node, 0) + 4;
    NodeHeight := Max(18, NodeHeight);
  end
  else
    NodeHeight := 18;
end;
</pre><br>
Теперь всё сделано верно.<br>
<br>
<b>8.9. Фон дерева.</b><br>
Последнее наше упущение – параметры&nbsp;<b>Background</b>,&nbsp;<b>BackgroundOffsetX</b>&nbsp;и&nbsp;<b>BackgroundOffsetY</b>.<br>
Используются  они, когда необходимо нарисовать на фоне дерева что-то наподобие  тематической картинки, «водяного» (прозрачного) знака. Яркий пример –  папки картинок или музыки в Windows XP, где в нижнем правом углу  изображена тематическая картинка для каждой из папок, отражающая её  суть.<br>
Background – сама картинка, которая будет отображаться.<br>
BackgroundOffsetX и BackgroundOffsetY – её смещения по X и Y координатам соответственно.<br>
Для включения отображения картинки необходимо установить опцию дерева TreeOptions.PaintOptions.<b>toShowBackground</b>&nbsp;в  True. Опция toStaticBackround из того же раздела позволяет разрешить  или запретить заполнение дерева изображением на всю видимую область.<br>
В событии OnResize очень удобно изменять положение картинки, например, центрировать её: </div><pre class="brush: pascal">	
//---------------------------------------------------------------------------
// Располагаем фоновую картинку по центру
//---------------------------------------------------------------------------
procedure TfrmMain.VTResize(Sender: TObject);
begin
  VT.BackgroundOffsetX := (VT.Width div 2) - (VT.Background.Width div 2);
  VT.BackgroundOffsetY := (VT.Height div 2) - (VT.Background.Height div 2);
end;
</pre><br>
<b>Добавлено @ 00:39</b><br>
<b>9.0. Настройки VT.</b><br>
Как Я и обещал, привожу полный список настроек VT (TreeOptions) с описанием назначения каждого параметра.<br>
<ul><li><b>AnimationOptions</b>:<ul><li><b>toAnimatedToggle</b>&nbsp;– отвечает за анимацию свёртывания/развёртывания.</li>
</ul></li>
<li><b>AutoOptions</b>:<ul><li><b>toAutoDropExpand</b>&nbsp;–  развёртывает узел, если он будет оставаться целью drag&amp;drop  (DropTargetNode) некоторое время, заданное параметром AutoExpandDelay.  Рекомендуется установить в True.</li>
<li><b>toAutoExpand</b>&nbsp;– автоматически раскрывает/сворачивает узел при получении им фокуса.</li>
<li><b>toAutoScroll</b>&nbsp;– прокручивает дерево, если происходит операция drag&amp;drop и курсор мыши находится рядом с краями дерева.</li>
<li><b>toAutoScrollOnExpand</b>&nbsp;– прокручивает дерево на максимально возможное число позиций при развёртывании узла.</li>
<li><b>toAutoSort</b>&nbsp;–  автоматически сортирует дерево при изменении параметров  Header.SortDirection, или Header.SortColumn, или при добавлении нового  узла.</li>
<li><b>toAutoSpanColumns</b>&nbsp;– довольно необычная опция.  Она позволяет перенести текст, не помещающийся в данной колонке на  соседнюю, если она пуста (не содержит текста).</li>
<li><b>toAutoTristateTracking</b>&nbsp;– автоматическое отслеживание grayed-состояния для узлов с типом отметки ctTriStateCheckBox.</li>
<li><b>toAutoHideButtons</b>&nbsp;–  кнопки развёртывания/свёртывания будут автоматически скрываться для  данного узла, если все его дочерние будут спрятаны (vsVisible).</li>
<li><b>toAutoDeleteMovedNodes</b>&nbsp;– источники перемещённых узлов будут автоматически удаляться после операций drag&amp;drop.</li>
<li><b>toDisableAutoscrollOnFocus</b>&nbsp;– выключает автоматическую прокрутку колонки к видимой области, если она получает фокус.</li>
<li><b>toAutoChangeScale</b>&nbsp;– изменяет высоту узлов в соответствии с настройками размера шрифтов Windows.</li>
<li><b>toAutoFreeOnCollapse</b>&nbsp;– при сворачивании узла все его дочерние узлы будут удалены, но опция vsHasChildren для данного узла сохранится.</li>
<li><b>toDisableAutoscrollOnEdit</b>&nbsp;–  не прокручивает дерево в горизонтальном направлении при редактировании  узла, чтобы расположить видимую область по центру.</li>
</ul></li>
<li><b>MiscOptions</b>:<ul><li><b>toAcceptOLEDrop</b>&nbsp;– зарегестрировать дерево, как возможную цель для OLE drag&amp;drop.</li>
<li><b>toCheckSupport</b>&nbsp;– включить поддержку отметок для узлов.</li>
<li><b>toEditable</b>&nbsp;– включить режим редактирования для узлов. В этом случае станет доступен стандартный редактор VT и Ваши собственные.</li>
<li><b>toFullRepaintOnResize</b>&nbsp;– полностью перерисовывать дерево при любом изменении его размеров.</li>
<li><b>toGridExtensions</b>&nbsp;–  включить поддержку некоторых расширений для симуляции элемента  управления сетки (а-ля TDBGrid). В частности, изменяется реакция на  некоторые горячие клавиши. Удобно использовать при создании приложений  баз данных с VT.</li>
<li><b>toInitOnSave</b>&nbsp;– производить инициализацию узлов при сохранении в поток или файл.</li>
<li><b>toReportMode</b>&nbsp;– дерево ведёт себя как TTListView с поддержкой report mode.</li>
<li><b>toToggleOnDblClick</b>&nbsp;– узлы будут сворачиваться/разворачиваться при двойном клике на них.</li>
<li><b>toWheelPanning</b>&nbsp;–  разрешает навигацию по дереву с помощью движений мыши (panning). Это  особый режим прокрутки дерева, в который оно входит по нажатию средней  кнопки мыши. После этого курсор начнёт принимать вид стрелок и дерево  можно будет прокручивать по определённым направлениям, передвигая курсор  к соответствующим краям дерева. Чем ближе пододвигать курсор, тем  быстрее будет происходить прокрутка.</li>
<li><b>toReadOnly</b>&nbsp;– запрещается любое изменение дерева, в том числе взаимодействие с узлами и их редактирование.</li>
<li><b>toVariableNodeHeight</b>&nbsp;–  включается, когда требуется отображение узлов различной высоты. В этом  случае высоту узлов дерево будет получать из обработчика события  OnMeasureItem.</li>
<li><b>toFullRowDrag</b>&nbsp;– разрешает начало  перетаскивания узла при нажатии мышью в любую область узла, а не  обязательно по тексту или картинке. Должно использоваться вместе с  опцией toDisableDrawSelection.</li>
</ul></li>
<li><b>PaintOptions</b>:<ul><li><b>toHideFocusRect</b>&nbsp;– не отображает пунктирный прямоугольник фокуса по границам узла.</li>
<li><b>toHideSelection</b>&nbsp;–  не отображает бежевый (по умолчанию) прямоугольник выделения для  выделенных узлов, когда само дерево не имеет фокуса. В этом случае,  когда дерево не будет иметь фокуса, Вы не сможете разобрать выделенные  узлы от не выделенных.</li>
<li><b>toHotTrack</b>&nbsp;– включает  отслеживание узла, находящегося под курсором. По умолчанию, такой узел  будет отображаться подчёркнутым, если Вы включите эту опцию.</li>
<li><b>toPopupMode</b>&nbsp;– отображает дерево, как будто бы оно всегда имеет фокус.</li>
<li><b>toShowBackground</b>&nbsp;– отрисовывать фоновую картинку, если есть (параметр Background).</li>
<li><b>toShowButtons</b>&nbsp;– Отображать кнопки развёртывания/свёртывания напротив узлов.</li>
<li><b>toShowDropmark</b>&nbsp;– показывать значок, отображающий положение будущего узла при операциях drag&amp;drop.</li>
<li><b>toShowHorzGridLines</b>&nbsp;– включить отображение горизонтальных линий сетки.</li>
<li><b>toShowRoot</b>&nbsp;–  учитывать отступ и рисовать соединительные линии для самых верхних  узлов первого уровня вложенности (дочерних узлов RootNode).</li>
<li><b>toShowTreeLines</b>&nbsp;– отображать соединительные линии для узлов.</li>
<li><b>toShowVertGridLines</b>&nbsp;– включить отображение вертикальных линий сетки.</li>
<li><b>toThemeAware</b>&nbsp;–  включает отображении всех элементов управления дерева (кнопок, отметок и  т.д.) в соответствии с текущей темой оформления Windows XP. Приложение  должно поддерживать визуальные темы оформления.</li>
<li><b>toUseBlendedImages</b>&nbsp;– включить прозрачность для ghosted-узлов и для узлов, участвующих на данный момент в копировании/вырезании.</li>
<li><b>toGhostedIfUnfocused</b>&nbsp;– картинки будут отображаться прозрачными до тех пор, пока узел не будет выделен.</li>
<li><b>toFullVertGridLines</b>&nbsp;–  продливает вертикальные линии сетки до конца дерева. Если данная опция  будет отключена, то линии закончатся на последнем видимом узле.</li>
<li><b>toAlwaysHideSelection</b>&nbsp;– отображает узлы как невыделенные независимо от их состояния.</li>
<li><b>toUseBlendedSelection</b>&nbsp;– отображать выделенные узлы прозрачными.</li>
<li><b>toStaticBackground</b>&nbsp;– запрещает заполнять фоновой картинкой видимую область дерева.</li>
</ul></li>
<li><b>SelectionOptions (только для TVirtualStringTree дерева)</b>:<ul><li><b>toDisableDrawSelection</b>&nbsp;– запрещает пользователю добавлять в текущее выделение узлы с помощью прямоугольника выделения.</li>
<li><b>toExtendedFocus</b>&nbsp;– позволяет выделять ячейки и редактировать текст во всех колонках, а не только в MainColumn.</li>
<li><b>toFullRowSelect</b>&nbsp;–  дерево будет рисовать прямоугольник выделения на всю свою ширину для  данного узла. Таким образом, длина прямоугольника выделения не будет  зависеть от ширины текста. Помимо этого, узлы можно будет выбирать  нажатием мыши в любую область дерева, а не только по тексту узла.</li>
<li><b>toLevelSelectConstraint</b>&nbsp;–  запрещает выделение узлов различных уровней. Это означает, что в  текущее выделение смогут попасть только узлы с таким же уровнем  вложенности, что и у первого выделенного.</li>
<li><b>toMiddleClickSelect</b>&nbsp;– разрешает выделение узлов средней кнопкой мыши.</li>
<li><b>toMultiSelect</b>&nbsp;– разрешает выделение более чем одного узла.</li>
<li><b>toRightClickSelect</b>&nbsp;– разрешает выделение узлов правой кнопкой мыши.</li>
<li><b>toSiblingSelectConstraint</b>&nbsp;– ограничивает текущее выделение только узлами одного и того же родителя.</li>
<li><b>toCenterScrollIntoView</b>&nbsp;–  располагает видимую (клиентскую) область дерева центрально по вертикали  по отношению к узлу, получающему фокус. Очень удобно для длинных  списков.</li>
<li><b>toSimpleDrawSelection</b>&nbsp;– упрощает операцию  выделения узлов, в частности, не требует, чтобы прямоугольник выделения  пересёкся с текстом узла для его выделения. Если опция будет установлена  в False, то для выделения узла придётся тащить прямоугольник выделения  до текста MainColumn колонки.</li>
</ul></li>
<li><b>StringOptions</b>:<ul><li><b>toSaveCaptions</b>&nbsp;–  сохраняет текст из ячеек узла при операциях с буфером обмена,  drag&amp;drop и при сохранении в поток или файл. Рекомендуется включать  при drag&amp;drop и выключать при работе с файлами, т.к. сохранение  данных узла в потоке строго рекомендуется делать самостоятельно.</li>
<li><b>toShowStaticText</b>&nbsp;–  включает отображение статического текста, который отображается рядом с  обычным, но в отличие от него не может быть отредактирован редактором  VT.</li>
<li><b>toAutoAcceptEditChange</b>&nbsp;– автоматически принимать  отредактированный текст, если редактирование не было отклонено по Esc  или завершено по Enter. В этом случае новый текст передаётся в  обработчик события OnNewText.</li>
</ul></li>
</ul><b>Добавлено @ 00:39</b><br>
<b>10.0. Заключение.</b><br>
Вот,  наконец, мы и подошли к концу. Теперь Вы можете быть твёрдо уверены,  что знаете о VT более чем достаточно. Я старался сделать статью как  можно более полной и информативной, не упуская ни единого параметра и  события, в отличие от официального хелпа по компоненту, но, к сожалению,  везде есть свои рамки, и поэтому конечно что-то осталось за кадром, а о  чём-то Я просто мог забыть упомянуть. Если бы Я уделял пристальное  внимание абсолютно каждому элементу VT, то и без того получившаяся  большая статья растянулась бы страниц на сто и походила бы скорее на  полноценное печатное издание&nbsp;<img alt="smile" src="./Статья_files/smile_002.gif">.  Нами остались нерассмотренными всего несколько событий компонента, не  имеющие принципиального значения. Это, к примеру, OnResetNode,  OnShortenString, OnGetPopupMenu. Уверен, Вам самим будет интересно  разобраться в них самостоятельно.<br>
Я надеюсь, что Вам понравился  компонент, и Вы убедились в его исключительной мощности и удобстве.  Думаю, теперь VT станет вашим повседневным компонентом номер один, а про  TTreeView и TListView Вы забудете, как о страшном сне. И, конечно же, Я  надеюсь, что Я выполнил поставленную перед собой цель и Вам понравилась  моя статья&nbsp;<img alt="smile" src="./Статья_files/smile_002.gif">.<br>
<br>
P.S<br>
Заранее прошу прощения за ошибки и опечатки в статье. Старался исправлять орфографию и грамматику как мог&nbsp;<img alt="smile" src="./Статья_files/smile_002.gif">.<br>
<br>
P.S.S<br>
Исходные коды примеров и полную версию самой статьи в формате Microsoft Word можно скачать по адресу:<br>
<a href="http://quadr0.pochta.ru/VirtualTreeview/virtualtreeview.zip" target="_blank">http://quadr0.pochta.ru/VirtualTreeview/virtualtreeview.zip</a><br>
<br>
Скомпилированные примеры можно взять отсюда:<br>
<a href="http://quadr0.pochta.ru/virtualtreeview/figures.zip" target="_blank">http://quadr0.pochta.ru/VirtualTreeview/figures.zip</a> </div>
<div style="clear: both;"></div>
</div>
<div class="post-footer">
<div class="post-footer-line post-footer-line-1"><span class="post-author vcard">
Автор:
<span class="fn">cii</span>
</span>
<span class="post-timestamp">
на
<a class="timestamp-link" href="http://delphigears.blogspot.ru/2011/08/virtual-treeview.html" rel="bookmark" title="permanent link"><abbr class="published" title="2011-08-17T04:25:00-07:00">4:25</abbr></a>
</span>
<span class="post-comment-link">
<a class="comment-link" href="http://delphigears.blogspot.ru/2011/08/virtual-treeview.html#comment-form" onclick="">4
коммент.</a>
</span>
<span class="post-icons">
<span class="item-control blog-admin pid-1600206169">
<a href="https://www.blogger.com/post-edit.g?blogID=7144240761607552042&amp;postID=5600195645677483363&amp;from=pencil" title="Изменить сообщение">
<img alt="" class="icon-action" height="18" src="./Статья_files/icon18_edit_allbkg.gif" width="18">
</a>
</span>
</span>
<div class="post-share-buttons goog-inline-block">
<a class="goog-inline-block share-button sb-email" href="https://www.blogger.com/share-post.g?blogID=7144240761607552042&amp;postID=5600195645677483363&amp;target=email" target="_blank" title="Отправить по электронной почте"><span class="share-button-link-text">Отправить по электронной почте</span></a><a class="goog-inline-block share-button sb-blog" href="https://www.blogger.com/share-post.g?blogID=7144240761607552042&amp;postID=5600195645677483363&amp;target=blog" onclick="window.open(this.href, &quot;_blank&quot;, &quot;height=270,width=475&quot;); return false;" target="_blank" title="Написать об этом в блоге"><span class="share-button-link-text">Написать об этом в блоге</span></a><a class="goog-inline-block share-button sb-twitter" href="https://www.blogger.com/share-post.g?blogID=7144240761607552042&amp;postID=5600195645677483363&amp;target=twitter" target="_blank" title="Опубликовать в Twitter"><span class="share-button-link-text">Опубликовать в Twitter</span></a><a class="goog-inline-block share-button sb-facebook" href="https://www.blogger.com/share-post.g?blogID=7144240761607552042&amp;postID=5600195645677483363&amp;target=facebook" onclick="window.open(this.href, &quot;_blank&quot;, &quot;height=430,width=640&quot;); return false;" target="_blank" title="Опубликовать в Facebook"><span class="share-button-link-text">Опубликовать в Facebook</span></a><a class="goog-inline-block share-button sb-pinterest" href="https://www.blogger.com/share-post.g?blogID=7144240761607552042&amp;postID=5600195645677483363&amp;target=pinterest" target="_blank" title="Поделиться в Pinterest"><span class="share-button-link-text">Поделиться в Pinterest</span></a><div class="goog-inline-block google-plus-share-container"><div id="___plusone_0" style="text-indent: 0px; margin: 0px; padding: 0px; border-style: none; float: none; line-height: normal; font-size: 1px; vertical-align: baseline; display: inline-block; width: 300px; height: 20px; background: transparent;"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="position: static; top: 0px; width: 300px; margin: 0px; border-style: none; left: 0px; visibility: visible; height: 20px;" tabindex="0" vspace="0" width="100%" id="I0_1473023991124" name="I0_1473023991124" src="./Статья_files/fastbutton.html" data-gapiattached="true" title="+1"></iframe></div></div>
</div>
</div>
<div class="post-footer-line post-footer-line-2"><span class="post-labels">
</span>
</div>
<div class="post-footer-line post-footer-line-3"><span class="post-location">
</span>
</div>
</div>
</div>
</div>

        </div></div>
      
</div>
<div class="blog-pager" id="blog-pager">
<a class="home-link" href="http://delphigears.blogspot.ru/">Главная страница</a>
</div>
<div class="clear"></div>
<div class="blog-feeds">
<div class="feed-links">
Подписаться на:
<a class="feed-link" href="http://delphigears.blogspot.com/feeds/posts/default" target="_blank" type="application/atom+xml">Сообщения (Atom)</a>
</div>
</div>
<script type="text/javascript">window.___gcfg = {'lang': 'ru'};</script>
</div></div>
</div>
</div>
<div class="column-left-outer">
<div class="column-left-inner">
<aside>
</aside>
</div>
</div>
<div class="column-right-outer">
<div class="column-right-inner">
<aside>
<div class="sidebar section" id="sidebar-right-1"><div class="widget Followers" data-version="1" id="Followers1">
<h2 class="title">Постоянные читатели</h2>
<div class="widget-content">
<div id="Followers1-wrapper">
<div style="margin-right:2px;">
<div><script type="text/javascript" src="./Статья_files/plusone.js" gapi_processed="true"></script>
<div id="followers-iframe-container"><iframe frameborder="0" hspace="0" marginheight="0" marginwidth="0" scrolling="no" style="" tabindex="0" vspace="0" width="100%" id="I0_1473023991139" name="I0_1473023991139" src="./Статья_files/followers.html" height="81"></iframe></div>
<script type="text/javascript">
    window.followersIframe = null;
    function followersIframeOpen(url) {
      gapi.load("gapi.iframes", function() {
        if (gapi.iframes && gapi.iframes.getContext) {
          window.followersIframe = gapi.iframes.getContext().openChild({
            url: url,
            where: document.getElementById("followers-iframe-container"),
            messageHandlersFilter: gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
            messageHandlers: {
              '_ready': function(obj) {
                window.followersIframe.getIframeEl().height = obj.height;
              },
              'reset': function() {
                window.followersIframe.close();
                followersIframeOpen("https://www.blogger.com/followers.g?blogID\x3d7144240761607552042\x26colors\x3dCgt0cmFuc3BhcmVudBILdHJhbnNwYXJlbnQaBjIyMjIyMiIGMjI4OGJiKgZmZmZmZmYyBjAwMDAwMDoGMjIyMjIyQgYyMjg4YmJKBjk5OTk5OVIGMjI4OGJiWgt0cmFuc3BhcmVudA%3D%3D\x26pageSize\x3d21\x26origin\x3dhttp://delphigears.blogspot.ru/");
              },
              'open': function(url) {
                window.followersIframe.close();
                followersIframeOpen(url);
              },
              'blogger-ping': function() {
              }
            }
          });
        }
      });
    }
    followersIframeOpen("https://www.blogger.com/followers.g?blogID\x3d7144240761607552042\x26colors\x3dCgt0cmFuc3BhcmVudBILdHJhbnNwYXJlbnQaBjIyMjIyMiIGMjI4OGJiKgZmZmZmZmYyBjAwMDAwMDoGMjIyMjIyQgYyMjg4YmJKBjk5OTk5OVIGMjI4OGJiWgt0cmFuc3BhcmVudA%3D%3D\x26pageSize\x3d21\x26origin\x3dhttp://delphigears.blogspot.ru/");
  </script></div>
</div>
</div>
<div class="clear"></div>
<span class="widget-item-control">
<span class="item-control blog-admin">
<a class="quickedit" href="http://www.blogger.com/rearrange?blogID=7144240761607552042&amp;widgetType=Followers&amp;widgetId=Followers1&amp;action=editWidget&amp;sectionId=sidebar-right-1" onclick="return _WidgetManager._PopupConfig(document.getElementById(&quot;Followers1&quot;));" target="configFollowers1" title="Изменить">
<img alt="" height="18" src="./Статья_files/icon18_wrench_allbkg.png" width="18">
</a>
</span>
</span>
<div class="clear"></div>
</div>
</div><div class="widget BlogArchive" data-version="1" id="BlogArchive1">
<h2>Архив блога</h2>
<div class="widget-content">
<div id="ArchiveList">
<div id="BlogArchive1_ArchiveList">
<ul class="hierarchy">
<li class="archivedate expanded">
<a class="toggle" href="javascript:void(0)">
<span class="zippy toggle-open">

        ▼&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://delphigears.blogspot.ru/search?updated-min=2011-01-01T00:00:00-08:00&amp;updated-max=2012-01-01T00:00:00-08:00&amp;max-results=1">
2011
</a>
<span class="post-count" dir="ltr">(1)</span>
<ul class="hierarchy">
<li class="archivedate expanded">
<a class="toggle" href="javascript:void(0)">
<span class="zippy toggle-open">

        ▼&nbsp;
      
</span>
</a>
<a class="post-count-link" href="http://delphigears.blogspot.ru/2011_08_01_archive.html">
августа
</a>
<span class="post-count" dir="ltr">(1)</span>
<ul class="posts">
<li><a href="http://delphigears.blogspot.ru/2011/08/virtual-treeview.html">Virtual Treeview</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="clear"></div>
<span class="widget-item-control">
<span class="item-control blog-admin">
<a class="quickedit" href="http://www.blogger.com/rearrange?blogID=7144240761607552042&amp;widgetType=BlogArchive&amp;widgetId=BlogArchive1&amp;action=editWidget&amp;sectionId=sidebar-right-1" onclick="return _WidgetManager._PopupConfig(document.getElementById(&quot;BlogArchive1&quot;));" target="configBlogArchive1" title="Изменить">
<img alt="" height="18" src="./Статья_files/icon18_wrench_allbkg.png" width="18">
</a>
</span>
</span>
<div class="clear"></div>
</div>
</div></div>
</aside>
</div>
</div>
</div>
<div style="clear: both"></div>
<!-- columns -->
</div>
<!-- main -->
</div>
</div>
<div class="main-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
<footer>
<div class="footer-outer">
<div class="footer-cap-top cap-top">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
<div class="fauxborder-left footer-fauxborder-left">
<div class="fauxborder-right footer-fauxborder-right"></div>
<div class="region-inner footer-inner">
<div class="foot no-items section" id="footer-1"></div>
<table border="0" cellpadding="0" cellspacing="0" class="section-columns columns-2">
<tbody>
<tr>
<td class="first columns-cell">
<div class="foot no-items section" id="footer-2-1"></div>
</td>
<td class="columns-cell">
<div class="foot no-items section" id="footer-2-2"></div>
</td>
</tr>
</tbody>
</table>
<!-- outside of the include in order to lock Attribution widget -->
<div class="foot section" id="footer-3"><div class="widget Attribution" data-version="1" id="Attribution1">
<div class="widget-content" style="text-align: center;">
Шаблон "Simple". Технологии <a href="https://www.blogger.com/" target="_blank">Blogger</a>.
</div>
<div class="clear"></div>
<span class="widget-item-control">
<span class="item-control blog-admin">
<a class="quickedit" href="http://www.blogger.com/rearrange?blogID=7144240761607552042&amp;widgetType=Attribution&amp;widgetId=Attribution1&amp;action=editWidget&amp;sectionId=footer-3" onclick="return _WidgetManager._PopupConfig(document.getElementById(&quot;Attribution1&quot;));" target="configAttribution1" title="Изменить">
<img alt="" height="18" src="./Статья_files/icon18_wrench_allbkg.png" width="18">
</a>
</span>
</span>
<div class="clear"></div>
</div></div>
</div>
</div>
<div class="footer-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</footer>
<!-- content -->
</div>
</div>
<div class="content-cap-bottom cap-bottom">
<div class="cap-left"></div>
<div class="cap-right"></div>
</div>
</div>
</div>
<script type="text/javascript">
    window.setTimeout(function() {
        document.body.className = document.body.className.replace('loading', '');
      }, 10);
  </script>

<script type="text/javascript" src="./Статья_files/1238587809-widgets.js"></script>
<script type="text/javascript" src="./Статья_files/plusone.js" gapi_processed="true"></script>
<script type="text/javascript">
window['__wavt'] = 'AOuZoY4xujNelaCX-IidOSCaThQaCM98Lw:1473023987243';_WidgetManager._Init('//www.blogger.com/rearrange?blogID\x3d7144240761607552042','//delphigears.blogspot.ru/','7144240761607552042');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'blogId': '7144240761607552042', 'bloggerUrl': 'https://www.blogger.com', 'title': 'Delphi Gears', 'pageType': 'index', 'url': 'http://delphigears.blogspot.ru/', 'canonicalUrl': 'http://delphigears.blogspot.com/', 'homepageUrl': 'http://delphigears.blogspot.ru/', 'searchUrl': 'http://delphigears.blogspot.ru/search', 'canonicalHomepageUrl': 'http://delphigears.blogspot.com/', 'blogspotFaviconUrl': 'http://delphigears.blogspot.ru/favicon.ico', 'enabledCommentProfileImages': true, 'adultContent': false, 'analyticsAccountNumber': '', 'useUniversalAnalytics': false, 'pageName': '', 'pageTitle': 'Delphi Gears', 'encoding': 'UTF-8', 'locale': 'ru', 'localeUnderscoreDelimited': 'ru', 'isPrivate': false, 'isMobile': false, 'isMobileRequest': false, 'mobileClass': '', 'isPrivateBlog': false, 'languageDirection': 'ltr', 'feedLinks': '\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22Delphi Gears - Atom\x22 href\x3d\x22http://delphigears.blogspot.com/feeds/posts/default\x22 /\x3e\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/rss+xml\x22 title\x3d\x22Delphi Gears - RSS\x22 href\x3d\x22http://delphigears.blogspot.com/feeds/posts/default?alt\x3drss\x22 /\x3e\n\x3clink rel\x3d\x22service.post\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22Delphi Gears - Atom\x22 href\x3d\x22https://www.blogger.com/feeds/7144240761607552042/posts/default\x22 /\x3e\n', 'meTag': '\x3clink rel\x3d\x22me\x22 href\x3d\x22https://www.blogger.com/profile/17990985288407310874\x22 /\x3e\n', 'openIdOpTag': '\x3clink rel\x3d\x22openid.server\x22 href\x3d\x22https://www.blogger.com/openid-server.g\x22 /\x3e\n\x3clink rel\x3d\x22openid.delegate\x22 href\x3d\x22http://delphigears.blogspot.com/\x22 /\x3e\n', 'mobileHeadScript': '', 'adsenseHostId': 'ca-host-pub-1556223355139109', 'ieCssRetrofitLinks': '\x3c!--[if IE]\x3e\x3cscript type\x3d\x22text/javascript\x22 src\x3d\x22https://www.blogger.com/static/v1/jsbin/4044097237-ieretrofit.js\x22\x3e\x3c/script\x3e\n\x3c![endif]--\x3e', 'view': '', 'dynamicViewsCommentsSrc': '//www.blogblog.com/dynamicviews/4224c15c4e7c9321/js/comments.js', 'dynamicViewsScriptSrc': '//www.blogblog.com/dynamicviews/ad021b563ad5846a', 'plusOneApiSrc': 'https://apis.google.com/js/plusone.js', 'sharing': {'platforms': [{'name': 'Получить ссылку', 'key': 'link', 'shareMessage': 'Получить ссылку', 'target': ''}, {'name': 'Facebook', 'key': 'facebook', 'shareMessage': 'Поделиться в Facebook', 'target': 'facebook'}, {'name': 'Написать об этом в блоге', 'key': 'blogThis', 'shareMessage': 'Написать об этом в блоге', 'target': 'blog'}, {'name': 'Twitter', 'key': 'twitter', 'shareMessage': 'Поделиться в Twitter', 'target': 'twitter'}, {'name': 'Pinterest', 'key': 'pinterest', 'shareMessage': 'Поделиться в Pinterest', 'target': 'pinterest'}, {'name': 'Google+', 'key': 'googlePlus', 'shareMessage': 'Поделиться в Google+', 'target': 'googleplus'}, {'name': 'Электронная почта', 'key': 'email', 'shareMessage': 'Электронная почта', 'target': 'email'}], 'googlePlusShareButtonWidth': 300, 'googlePlusBootstrap': '\x3cscript type\x3d\x22text/javascript\x22\x3ewindow.___gcfg \x3d {\x27lang\x27: \x27ru\x27};\x3c/script\x3e'}}}, {'name': 'features', 'data': {'widgetVisibility': true}}, {'name': 'template', 'data': {'name': 'Simple', 'localizedName': 'Простая', 'variant': 'pale', 'isResponsive': false, 'isAlternateRendering': false, 'isCustom': false}}, {'name': 'view', 'data': {'classic': {'name': 'classic', 'url': '?view\x3dclassic'}, 'flipcard': {'name': 'flipcard', 'url': '?view\x3dflipcard'}, 'magazine': {'name': 'magazine', 'url': '?view\x3dmagazine'}, 'mosaic': {'name': 'mosaic', 'url': '?view\x3dmosaic'}, 'sidebar': {'name': 'sidebar', 'url': '?view\x3dsidebar'}, 'snapshot': {'name': 'snapshot', 'url': '?view\x3dsnapshot'}, 'timeslide': {'name': 'timeslide', 'url': '?view\x3dtimeslide'}, 'title': 'Delphi Gears', 'description': '', 'url': 'http://delphigears.blogspot.ru/', 'type': 'feed', 'isPage': false, 'isPost': false, 'isHomepage': true, 'isArchive': false, 'isSearch': false}}]);
_WidgetManager._RegisterWidget('_NavbarView', new _WidgetInfo('Navbar1', 'navbar', null, document.getElementById('Navbar1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_HeaderView', new _WidgetInfo('Header1', 'header', null, document.getElementById('Header1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main', null, document.getElementById('Blog1'), {'cmtInteractionsEnabled': false, 'lightboxEnabled': true, 'lightboxModuleUrl': 'https://www.blogger.com/static/v1/jsbin/3894519483-lbx__ru.js', 'lightboxCssUrl': 'https://www.blogger.com/static/v1/v-css/368954415-lightbox_bundle.css'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_FollowersView', new _WidgetInfo('Followers1', 'sidebar-right-1', null, document.getElementById('Followers1'), {}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_BlogArchiveView', new _WidgetInfo('BlogArchive1', 'sidebar-right-1', null, document.getElementById('BlogArchive1'), {'languageDirection': 'ltr', 'loadingMessage': 'Загрузка...'}, 'displayModeFull'));
_WidgetManager._RegisterWidget('_AttributionView', new _WidgetInfo('Attribution1', 'footer-3', null, document.getElementById('Attribution1'), {'attribution': 'Шаблон \x22Simple\x22. Технологии \x3ca href\x3d\x27https://www.blogger.com\x27 target\x3d\x27_blank\x27\x3eBlogger\x3c/a\x3e.'}, 'displayModeFull'));
</script>

<iframe name="oauth2relay618664780" id="oauth2relay618664780" src="./Статья_files/postmessageRelay.html" tabindex="-1" style="width: 1px; height: 1px; position: absolute; top: -100px;"></iframe></body></html>